"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6927],{12383:function(t,e,r){r.d(e,{checkout:function(){return Ee},clone:function(){return Qe},version:function(){return tr}});var s=r(88047),i=r(61491),n=r(70090),a=r(26230),o=r(59066),c=(r(24673),r(27370)),d=(r(59700),r(55872).Buffer);class l extends Error{constructor(t){super(t),this.caller=""}toJSON(){return{code:this.code,data:this.data,caller:this.caller,message:this.message,stack:this.stack}}fromJSON(t){const e=new l(t.message);return e.code=t.code,e.data=t.data,e.caller=t.caller,e.stack=t.stack,e}get isIsomorphicGitError(){return!0}}class f extends l{constructor(t){super(`Modifying the index is not possible because you have unmerged files: ${t.toString}. Fix them up in the work tree, and then use 'git add/rm as appropriate to mark resolution and make a commit.`),this.code=this.name=f.code,this.data={filepaths:t}}}f.code="UnmergedPathsError";class u extends l{constructor(t){super(`An internal error caused this command to fail. Please file a bug report at https://github.com/isomorphic-git/isomorphic-git/issues with this error message: ${t}`),this.code=this.name=u.code,this.data={message:t}}}u.code="InternalError";class h extends l{constructor(t){super(`The filepath "${t}" contains unsafe character sequences`),this.code=this.name=h.code,this.data={filepath:t}}}h.code="UnsafeFilepathError";class p{constructor(t){this.buffer=t,this._start=0}eof(){return this._start>=this.buffer.length}tell(){return this._start}seek(t){this._start=t}slice(t){const e=this.buffer.slice(this._start,this._start+t);return this._start+=t,e}toString(t,e){const r=this.buffer.toString(t,this._start,this._start+e);return this._start+=e,r}write(t,e,r){const s=this.buffer.write(t,this._start,e,r);return this._start+=e,s}copy(t,e,r){const s=t.copy(this.buffer,this._start,e,r);return this._start+=s,s}readUInt8(){const t=this.buffer.readUInt8(this._start);return this._start+=1,t}writeUInt8(t){const e=this.buffer.writeUInt8(t,this._start);return this._start+=1,e}readUInt16BE(){const t=this.buffer.readUInt16BE(this._start);return this._start+=2,t}writeUInt16BE(t){const e=this.buffer.writeUInt16BE(t,this._start);return this._start+=2,e}readUInt32BE(){const t=this.buffer.readUInt32BE(this._start);return this._start+=4,t}writeUInt32BE(t){const e=this.buffer.writeUInt32BE(t,this._start);return this._start+=4,e}}function m(t,e){return-(t<e)||+(t>e)}function w(t,e){return m(t.path,e.path)}function g(t){let e=t>0?t>>12:0;4!==e&&8!==e&&10!==e&&14!==e&&(e=8);let r=511&t;return r=73&r?493:420,8!==e&&(r=0),(e<<12)+r}const y=2**32;function b(t,e,r,s){if(void 0!==t&&void 0!==e)return[t,e];void 0===r&&(r=s.valueOf());const i=Math.floor(r/1e3);return[i,1e6*(r-1e3*i)]}function _(t){const[e,r]=b(t.ctimeSeconds,t.ctimeNanoseconds,t.ctimeMs,t.ctime),[s,i]=b(t.mtimeSeconds,t.mtimeNanoseconds,t.mtimeMs,t.mtime);return{ctimeSeconds:e%y,ctimeNanoseconds:r%y,mtimeSeconds:s%y,mtimeNanoseconds:i%y,dev:t.dev%y,ino:t.ino%y,mode:g(t.mode%y),uid:t.uid%y,gid:t.gid%y,size:t.size>-1?t.size%y:0}}let $=null;async function x(t){return null===$&&($=await async function(){try{if("da39a3ee5e6b4b0d3255bfef95601890afd80709"===await E(new Uint8Array([])))return!0}catch(t){}return!1}()),$?E(t):function(t){return(new i).update(t).digest("hex")}(t)}async function E(t){return function(t){let e="";for(const r of new Uint8Array(t))r<16&&(e+="0"),e+=r.toString(16);return e}(await crypto.subtle.digest("SHA-1",t))}class v{constructor(t,e){this._dirty=!1,this._unmergedPaths=e||new Set,this._entries=t||new Map}_addEntry(t){if(0===t.flags.stage)t.stages=[t],this._entries.set(t.path,t),this._unmergedPaths.delete(t.path);else{let e=this._entries.get(t.path);e||(this._entries.set(t.path,t),e=t),e.stages[t.flags.stage]=t,this._unmergedPaths.add(t.path)}}static async from(t){if(d.isBuffer(t))return v.fromBuffer(t);if(null===t)return new v(null);throw new u("invalid type passed to GitIndex.from")}static async fromBuffer(t){if(0===t.length)throw new u("Index file is empty (.git/index)");const e=new v,r=new p(t),s=r.toString("utf8",4);if("DIRC"!==s)throw new u(`Invalid dircache magic file number: ${s}`);const i=await x(t.slice(0,-20)),n=t.slice(-20).toString("hex");if(n!==i)throw new u(`Invalid checksum in GitIndex buffer: expected ${n} but saw ${i}`);const a=r.readUInt32BE();if(2!==a)throw new u(`Unsupported dircache version: ${a}`);const o=r.readUInt32BE();let c=0;for(;!r.eof()&&c<o;){const s={};s.ctimeSeconds=r.readUInt32BE(),s.ctimeNanoseconds=r.readUInt32BE(),s.mtimeSeconds=r.readUInt32BE(),s.mtimeNanoseconds=r.readUInt32BE(),s.dev=r.readUInt32BE(),s.ino=r.readUInt32BE(),s.mode=r.readUInt32BE(),s.uid=r.readUInt32BE(),s.gid=r.readUInt32BE(),s.size=r.readUInt32BE(),s.oid=r.slice(20).toString("hex");const i=r.readUInt16BE();s.flags=(d=i,{assumeValid:Boolean(32768&d),extended:Boolean(16384&d),stage:(12288&d)>>12,nameLength:4095&d});const n=t.indexOf(0,r.tell()+1)-r.tell();if(n<1)throw new u(`Got a path length of: ${n}`);if(s.path=r.toString("utf8",n),s.path.includes("..\\")||s.path.includes("../"))throw new h(s.path);let a=8-(r.tell()-12)%8;for(0===a&&(a=8);a--;){const t=r.readUInt8();if(0!==t)throw new u(`Expected 1-8 null characters but got '${t}' after ${s.path}`);if(r.eof())throw new u("Unexpected end of file")}s.stages=[],e._addEntry(s),c++}var d;return e}get unmergedPaths(){return[...this._unmergedPaths]}get entries(){return[...this._entries.values()].sort(w)}get entriesMap(){return this._entries}get entriesFlat(){return[...this.entries].flatMap((t=>t.stages.length>1?t.stages.filter((t=>t)):t))}*[Symbol.iterator](){for(const t of this.entries)yield t}insert({filepath:t,stats:e,oid:r,stage:s=0}){e||(e={ctimeSeconds:0,ctimeNanoseconds:0,mtimeSeconds:0,mtimeNanoseconds:0,dev:0,ino:0,mode:0,uid:0,gid:0,size:0}),e=_(e);const i=d.from(t),n={ctimeSeconds:e.ctimeSeconds,ctimeNanoseconds:e.ctimeNanoseconds,mtimeSeconds:e.mtimeSeconds,mtimeNanoseconds:e.mtimeNanoseconds,dev:e.dev,ino:e.ino,mode:e.mode||33188,uid:e.uid,gid:e.gid,size:e.size,path:t,oid:r,flags:{assumeValid:!1,extended:!1,stage:s,nameLength:i.length<4095?i.length:4095},stages:[]};this._addEntry(n),this._dirty=!0}delete({filepath:t}){if(this._entries.has(t))this._entries.delete(t);else for(const e of this._entries.keys())e.startsWith(t+"/")&&this._entries.delete(e);this._unmergedPaths.has(t)&&this._unmergedPaths.delete(t),this._dirty=!0}clear(){this._entries.clear(),this._dirty=!0}has({filepath:t}){return this._entries.has(t)}render(){return this.entries.map((t=>`${t.mode.toString(8)} ${t.oid}    ${t.path}`)).join("\n")}static async _entryToBuffer(t){const e=d.from(t.path),r=8*Math.ceil((62+e.length+1)/8),s=d.alloc(r),i=new p(s),n=_(t);return i.writeUInt32BE(n.ctimeSeconds),i.writeUInt32BE(n.ctimeNanoseconds),i.writeUInt32BE(n.mtimeSeconds),i.writeUInt32BE(n.mtimeNanoseconds),i.writeUInt32BE(n.dev),i.writeUInt32BE(n.ino),i.writeUInt32BE(n.mode),i.writeUInt32BE(n.uid),i.writeUInt32BE(n.gid),i.writeUInt32BE(n.size),i.write(t.oid,20,"hex"),i.writeUInt16BE(function(t){const e=t.flags;return e.extended=!1,e.nameLength=Math.min(d.from(t.path).length,4095),(e.assumeValid?32768:0)+(e.extended?16384:0)+((3&e.stage)<<12)+(4095&e.nameLength)}(t)),i.write(t.path,e.length,"utf8"),s}async toObject(){const t=d.alloc(12),e=new p(t);e.write("DIRC",4,"utf8"),e.writeUInt32BE(2),e.writeUInt32BE(this.entriesFlat.length);let r=[];for(const a of this.entries)if(r.push(v._entryToBuffer(a)),a.stages.length>1)for(const t of a.stages)t&&t!==a&&r.push(v._entryToBuffer(t));r=await Promise.all(r);const s=d.concat(r),i=d.concat([t,s]),n=await x(i);return d.concat([i,d.from(n,"hex")])}}function k(t,e){const r=_(t),s=_(e);return r.mode!==s.mode||r.mtimeSeconds!==s.mtimeSeconds||r.ctimeSeconds!==s.ctimeSeconds||r.uid!==s.uid||r.gid!==s.gid||r.ino!==s.ino||r.size!==s.size}let S=null;const P=Symbol("IndexCache");class I{static async acquire({fs:t,gitdir:e,cache:r,allowUnmerged:i=!0},n){r[P]||(r[P]={map:new Map,stats:new Map});const a=`${e}/index`;let o;null===S&&(S=new s({maxPending:1/0}));let c=[];return await S.acquire(a,(async()=>{await async function(t,e,r){const s=r.stats.get(e);if(void 0===s)return!0;const i=await t.lstat(e);return null!==s&&null!==i&&k(s,i)}(t,a,r[P])&&await async function(t,e,r){const s=await t.lstat(e),i=await t.read(e),n=await v.from(i);r.map.set(e,n),r.stats.set(e,s)}(t,a,r[P]);const e=r[P].map.get(a);if(c=e.unmergedPaths,c.length&&!i)throw new f(c);if(o=await n(e),e._dirty){const s=await e.toObject();await t.write(a,s),r[P].stats.set(a,await t.lstat(a)),e._dirty=!1}})),o}}function A(t){const e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\"));return e>-1&&(t=t.slice(e+1)),t}function j(t){const e=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\"));return-1===e?".":0===e?"/":t.slice(0,e)}function U(t){const e=new Map,r=function(t){if(!e.has(t)){const s={type:"tree",fullpath:t,basename:A(t),metadata:{},children:[]};e.set(t,s),s.parent=r(j(t)),s.parent&&s.parent!==s&&s.parent.children.push(s)}return e.get(t)},s=function(t,s){if(!e.has(t)){const i={type:"blob",fullpath:t,basename:A(t),metadata:s,parent:r(j(t)),children:[]};i.parent&&i.parent.children.push(i),e.set(t,i)}return e.get(t)};r(".");for(const i of t)s(i.path,i);return e}class C{constructor({fs:t,gitdir:e,cache:r}){this.treePromise=I.acquire({fs:t,gitdir:e,cache:r},(async function(t){return U(t.entries)}));const s=this;this.ConstructEntry=class{constructor(t){this._fullpath=t,this._type=!1,this._mode=!1,this._stat=!1,this._oid=!1}async type(){return s.type(this)}async mode(){return s.mode(this)}async stat(){return s.stat(this)}async content(){return s.content(this)}async oid(){return s.oid(this)}}}async readdir(t){const e=t._fullpath,r=(await this.treePromise).get(e);if(!r)return null;if("blob"===r.type)return null;if("tree"!==r.type)throw new Error(`ENOTDIR: not a directory, scandir '${e}'`);const s=r.children.map((t=>t.fullpath));return s.sort(m),s}async type(t){return!1===t._type&&await t.stat(),t._type}async mode(t){return!1===t._mode&&await t.stat(),t._mode}async stat(t){if(!1===t._stat){const e=(await this.treePromise).get(t._fullpath);if(!e)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);const r="tree"===e.type?{}:_(e.metadata);t._type="tree"===e.type?"tree":function(t){switch(t){case 16384:return"tree";case 33188:case 33261:case 40960:return"blob";case 57344:return"commit"}throw new u(`Unexpected GitTree entry mode: ${t.toString(8)}`)}(r.mode),t._mode=r.mode,"tree"===e.type?t._stat=void 0:t._stat=r}return t._stat}async content(t){}async oid(t){if(!1===t._oid){const e=(await this.treePromise).get(t._fullpath);t._oid=e.metadata.oid}return t._oid}}const R=Symbol("GitWalkSymbol");function O(){const t=Object.create(null);return Object.defineProperty(t,R,{value:function({fs:t,gitdir:e,cache:r}){return new C({fs:t,gitdir:e,cache:r})}}),Object.freeze(t),t}class B extends l{constructor(t){super(`Could not find ${t}.`),this.code=this.name=B.code,this.data={what:t}}}B.code="NotFoundError";class N extends l{constructor(t,e,r,s){super(`Object ${t} ${s?`at ${s}`:""}was anticipated to be a ${r} but it is a ${e}.`),this.code=this.name=N.code,this.data={oid:t,actual:e,expected:r,filepath:s}}}N.code="ObjectTypeError";class D extends l{constructor(t){super(`Expected a 40-char hex object id but saw "${t}".`),this.code=this.name=D.code,this.data={value:t}}}D.code="InvalidOidError";class T extends l{constructor(t){super(`Could not find a fetch refspec for remote "${t}". Make sure the config file has an entry like the following:\n[remote "${t}"]\n\tfetch = +refs/heads/*:refs/remotes/origin/*\n`),this.code=this.name=T.code,this.data={remote:t}}}T.code="NoRefspecError";class M{constructor(t){if(this.refs=new Map,this.parsedConfig=[],t){let e=null;this.parsedConfig=t.trim().split("\n").map((t=>{if(/^\s*#/.test(t))return{line:t,comment:!0};const r=t.indexOf(" ");if(t.startsWith("^")){const r=t.slice(1);return this.refs.set(e+"^{}",r),{line:t,ref:e,peeled:r}}{const s=t.slice(0,r);return e=t.slice(r+1),this.refs.set(e,s),{line:t,ref:e,oid:s}}}))}return this}static from(t){return new M(t)}delete(t){this.parsedConfig=this.parsedConfig.filter((e=>e.ref!==t)),this.refs.delete(t)}toString(){return this.parsedConfig.map((({line:t})=>t)).join("\n")+"\n"}}class H{constructor({remotePath:t,localPath:e,force:r,matchPrefix:s}){Object.assign(this,{remotePath:t,localPath:e,force:r,matchPrefix:s})}static from(t){const[e,r,s,i,n]=t.match(/^(\+?)(.*?)(\*?):(.*?)(\*?)$/).slice(1),a="+"===e,o="*"===s;if(o!==("*"===n))throw new u("Invalid refspec");return new H({remotePath:r,localPath:i,force:a,matchPrefix:o})}translate(t){if(this.matchPrefix){if(t.startsWith(this.remotePath))return this.localPath+t.replace(this.remotePath,"")}else if(t===this.remotePath)return this.localPath;return null}reverseTranslate(t){if(this.matchPrefix){if(t.startsWith(this.localPath))return this.remotePath+t.replace(this.localPath,"")}else if(t===this.localPath)return this.remotePath;return null}}class G{constructor(t=[]){this.rules=t}static from(t){const e=[];for(const r of t)e.push(H.from(r));return new G(e)}add(t){const e=H.from(t);this.rules.push(e)}translate(t){const e=[];for(const r of this.rules)for(const s of t){const t=r.translate(s);t&&e.push([s,t])}return e}translateOne(t){let e=null;for(const r of this.rules){const s=r.translate(t);s&&(e=s)}return e}localNamespaces(){return this.rules.filter((t=>t.matchPrefix)).map((t=>t.localPath.replace(/\/$/,"")))}}function z(t,e){const r=t.replace(/\^\{\}$/,""),s=e.replace(/\^\{\}$/,""),i=-(r<s)||+(r>s);return 0===i?t.endsWith("^{}")?1:-1:i}function F(t){return t.replace(/\/\.\//g,"/").replace(/\/{2,}/g,"/").replace(/^\/\.$/,"/").replace(/^\.\/$/,".").replace(/^\.\//,"").replace(/\/\.$/,"").replace(/(.+)\/$/,"$1").replace(/^$/,".")}function W(...t){return F(t.map(F).join("/"))}const q=t=>{if("true"===(t=t.trim().toLowerCase())||"yes"===t||"on"===t)return!0;if("false"===t||"no"===t||"off"===t)return!1;throw Error(`Expected 'true', 'false', 'yes', 'no', 'on', or 'off', but got ${t}`)},L={core:{filemode:q,bare:q,logallrefupdates:q,symlinks:q,ignorecase:q,bigFileThreshold:t=>{t=t.toLowerCase();let e=parseInt(t);return t.endsWith("k")&&(e*=1024),t.endsWith("m")&&(e*=1048576),t.endsWith("g")&&(e*=1073741824),e}}},V=/^\[([A-Za-z0-9-.]+)(?: "(.*)")?\]$/,K=/^[A-Za-z0-9-.]+$/,Z=/^([A-Za-z][A-Za-z-]*)(?: *= *(.*))?$/,Y=/^[A-Za-z][A-Za-z-]*$/,J=/^(.*?)( *[#;].*)$/,X=t=>{const e=J.exec(t);if(null==e)return t;const[r,s]=e.slice(1);return Q(r)&&Q(s)?`${r}${s}`:r},Q=t=>(t.match(/(?:^|[^\\])"/g)||[]).length%2!==0,tt=t=>t.split("").reduce(((t,e,r,s)=>{const i='"'===e&&"\\"!==s[r-1],n="\\"===e&&'"'===s[r+1];return i||n?t:t+e}),""),et=t=>null!=t?t.toLowerCase():null,rt=(t,e,r)=>[et(t),e,et(r)].filter((t=>null!=t)).join("."),st=t=>{const e=t.split("."),r=e.shift(),s=e.pop(),i=e.length?e.join("."):void 0;return{section:r,subsection:i,name:s,path:rt(r,i,s),sectionPath:rt(r,i,null)}};class it{constructor(t){let e=null,r=null;this.parsedConfig=t.split("\n").map((t=>{let s=null,i=null;const n=t.trim(),a=(t=>{const e=V.exec(t);if(null!=e){const[t,r]=e.slice(1);return[t,r]}return null})(n),o=null!=a;if(o)[e,r]=a;else{const t=(t=>{const e=Z.exec(t);if(null!=e){const[t,r="true"]=e.slice(1),s=X(r);return[t,tt(s)]}return null})(n);null!=t&&([s,i]=t)}const c=rt(e,r,s);return{line:t,isSection:o,section:e,subsection:r,name:s,value:i,path:c}}))}static from(t){return new it(t)}async get(t,e=!1){const r=st(t).path,s=this.parsedConfig.filter((t=>t.path===r)).map((({section:t,name:e,value:r})=>{const s=L[t]&&L[t][e];return s?s(r):r}));return e?s:s.pop()}async getall(t){return this.get(t,!0)}async getSubsections(t){return this.parsedConfig.filter((e=>e.section===t&&e.isSection)).map((t=>t.subsection))}async deleteSection(t,e){this.parsedConfig=this.parsedConfig.filter((r=>!(r.section===t&&r.subsection===e)))}async append(t,e){return this.set(t,e,!0)}async set(t,e,r=!1){const{section:s,subsection:i,name:n,path:a,sectionPath:o}=st(t),c=(d=this.parsedConfig,l=t=>t.path===a,d.reduce(((t,e,r)=>l(e)?r:t),-1));var d,l;if(null==e)-1!==c&&this.parsedConfig.splice(c,1);else if(-1!==c){const t=this.parsedConfig[c],s=Object.assign({},t,{name:n,value:e,modified:!0});r?this.parsedConfig.splice(c+1,0,s):this.parsedConfig[c]=s}else{const t=this.parsedConfig.findIndex((t=>t.path===o)),r={section:s,subsection:i,name:n,value:e,modified:!0,path:a};if(K.test(s)&&Y.test(n))if(t>=0)this.parsedConfig.splice(t+1,0,r);else{const t={section:s,subsection:i,modified:!0,path:o};this.parsedConfig.push(t,r)}}}toString(){return this.parsedConfig.map((({line:t,section:e,subsection:r,name:s,value:i,modified:n=!1})=>n?null!=s&&null!=i?"string"===typeof i&&/[#;]/.test(i)?`\t${s} = "${i}"`:`\t${s} = ${i}`:null!=r?`[${e} "${r}"]`:`[${e}]`:t)).join("\n")}}class nt{static async get({fs:t,gitdir:e}){const r=await t.read(`${e}/config`,{encoding:"utf8"});return it.from(r)}static async save({fs:t,gitdir:e,config:r}){await t.write(`${e}/config`,r.toString(),{encoding:"utf8"})}}const at=t=>[`${t}`,`refs/${t}`,`refs/tags/${t}`,`refs/heads/${t}`,`refs/remotes/${t}`,`refs/remotes/${t}/HEAD`],ot=["config","description","index","shallow","commondir"];class ct{static async updateRemoteRefs({fs:t,gitdir:e,remote:r,refs:s,symrefs:i,tags:n,refspecs:a,prune:o=!1,pruneTags:c=!1}){for(const m of s.values())if(!m.match(/[0-9a-f]{40}/))throw new D(m);const d=await nt.get({fs:t,gitdir:e});if(!a){if(0===(a=await d.getall(`remote.${r}.fetch`)).length)throw new T(r);a.unshift(`+HEAD:refs/remotes/${r}/HEAD`)}const l=G.from(a),f=new Map;if(c){const r=await ct.listRefs({fs:t,gitdir:e,filepath:"refs/tags"});await ct.deleteRefs({fs:t,gitdir:e,refs:r.map((t=>`refs/tags/${t}`))})}if(n)for(const m of s.keys())if(m.startsWith("refs/tags")&&!m.endsWith("^{}")&&!(await ct.exists({fs:t,gitdir:e,ref:m}))){const t=s.get(m);f.set(m,t)}const u=l.translate([...s.keys()]);for(const[m,w]of u){const t=s.get(m);f.set(w,t)}const h=l.translate([...i.keys()]);for(const[m,w]of h){const t=i.get(m),e=l.translateOne(t);e&&f.set(w,`ref: ${e}`)}const p=[];if(o){for(const r of l.localNamespaces()){const s=(await ct.listRefs({fs:t,gitdir:e,filepath:r})).map((t=>`${r}/${t}`));for(const t of s)f.has(t)||p.push(t)}p.length>0&&await ct.deleteRefs({fs:t,gitdir:e,refs:p})}for(const[m,w]of f)await t.write(W(e,m),`${w.trim()}\n`,"utf8");return{pruned:p}}static async writeRef({fs:t,gitdir:e,ref:r,value:s}){if(!s.match(/[0-9a-f]{40}/))throw new D(s);await t.write(W(e,r),`${s.trim()}\n`,"utf8")}static async writeSymbolicRef({fs:t,gitdir:e,ref:r,value:s}){await t.write(W(e,r),`ref: ${s.trim()}\n`,"utf8")}static async deleteRef({fs:t,gitdir:e,ref:r}){return ct.deleteRefs({fs:t,gitdir:e,refs:[r]})}static async deleteRefs({fs:t,gitdir:e,refs:r}){await Promise.all(r.map((r=>t.rm(W(e,r)))));let s=await t.read(`${e}/packed-refs`,{encoding:"utf8"});const i=M.from(s),n=i.refs.size;for(const a of r)i.refs.has(a)&&i.delete(a);i.refs.size<n&&(s=i.toString(),await t.write(`${e}/packed-refs`,s,{encoding:"utf8"}))}static async resolve({fs:t,gitdir:e,ref:r,depth:s}){if(void 0!==s&&-1===--s)return r;let i;if(r.startsWith("ref: "))return r=r.slice("ref: ".length),ct.resolve({fs:t,gitdir:e,ref:r,depth:s});if(40===r.length&&/[0-9a-f]{40}/.test(r))return r;const n=await ct.packedRefs({fs:t,gitdir:e}),a=at(r).filter((t=>!ot.includes(t)));for(const o of a)if(i=await t.read(`${e}/${o}`,{encoding:"utf8"})||n.get(o),i)return ct.resolve({fs:t,gitdir:e,ref:i.trim(),depth:s});throw new B(r)}static async exists({fs:t,gitdir:e,ref:r}){try{return await ct.expand({fs:t,gitdir:e,ref:r}),!0}catch(s){return!1}}static async expand({fs:t,gitdir:e,ref:r}){if(40===r.length&&/[0-9a-f]{40}/.test(r))return r;const s=await ct.packedRefs({fs:t,gitdir:e}),i=at(r);for(const n of i){if(await t.exists(`${e}/${n}`))return n;if(s.has(n))return n}throw new B(r)}static async expandAgainstMap({ref:t,map:e}){const r=at(t);for(const s of r)if(await e.has(s))return s;throw new B(t)}static resolveAgainstMap({ref:t,fullref:e=t,depth:r,map:s}){if(void 0!==r&&-1===--r)return{fullref:e,oid:t};if(t.startsWith("ref: "))return t=t.slice("ref: ".length),ct.resolveAgainstMap({ref:t,fullref:e,depth:r,map:s});if(40===t.length&&/[0-9a-f]{40}/.test(t))return{fullref:e,oid:t};const i=at(t);for(const n of i){const t=s.get(n);if(t)return ct.resolveAgainstMap({ref:t.trim(),fullref:n,depth:r,map:s})}throw new B(t)}static async packedRefs({fs:t,gitdir:e}){const r=await t.read(`${e}/packed-refs`,{encoding:"utf8"});return M.from(r).refs}static async listRefs({fs:t,gitdir:e,filepath:r}){const s=ct.packedRefs({fs:t,gitdir:e});let i=null;try{i=await t.readdirDeep(`${e}/${r}`),i=i.map((t=>t.replace(`${e}/${r}/`,"")))}catch(n){i=[]}for(let a of(await s).keys())a.startsWith(r)&&(a=a.replace(r+"/",""),i.includes(a)||i.push(a));return i.sort(z),i}static async listBranches({fs:t,gitdir:e,remote:r}){return r?ct.listRefs({fs:t,gitdir:e,filepath:`refs/remotes/${r}`}):ct.listRefs({fs:t,gitdir:e,filepath:"refs/heads"})}static async listTags({fs:t,gitdir:e}){return(await ct.listRefs({fs:t,gitdir:e,filepath:"refs/tags"})).filter((t=>!t.endsWith("^{}")))}}function dt(t,e){return m(lt(t),lt(e))}function lt(t){return"040000"===t.mode?t.path+"/":t.path}function ft(t){switch(t){case"040000":return"tree";case"100644":case"100755":case"120000":return"blob";case"160000":return"commit"}throw new u(`Unexpected GitTree entry mode: ${t}`)}function ut(t){return!t.oid&&t.sha&&(t.oid=t.sha),t.mode=function(t){if("number"===typeof t&&(t=t.toString(8)),t.match(/^0?4.*/))return"040000";if(t.match(/^1006.*/))return"100644";if(t.match(/^1007.*/))return"100755";if(t.match(/^120.*/))return"120000";if(t.match(/^160.*/))return"160000";throw new u(`Could not understand file mode: ${t}`)}(t.mode),t.type||(t.type=ft(t.mode)),t}class ht{constructor(t){if(d.isBuffer(t))this._entries=function(t){const e=[];let r=0;for(;r<t.length;){const s=t.indexOf(32,r);if(-1===s)throw new u(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next space character.`);const i=t.indexOf(0,r);if(-1===i)throw new u(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next null character.`);let n=t.slice(r,s).toString("utf8");"40000"===n&&(n="040000");const a=ft(n),o=t.slice(s+1,i).toString("utf8");if(o.includes("\\")||o.includes("/"))throw new h(o);const c=t.slice(i+1,i+21).toString("hex");r=i+21,e.push({mode:n,path:o,oid:c,type:a})}return e}(t);else{if(!Array.isArray(t))throw new u("invalid type passed to GitTree constructor");this._entries=t.map(ut)}this._entries.sort(w)}static from(t){return new ht(t)}render(){return this._entries.map((t=>`${t.mode} ${t.type} ${t.oid}    ${t.path}`)).join("\n")}toObject(){const t=[...this._entries];return t.sort(dt),d.concat(t.map((t=>{const e=d.from(t.mode.replace(/^0/,"")),r=d.from(" "),s=d.from(t.path,"utf8"),i=d.from([0]),n=d.from(t.oid,"hex");return d.concat([e,r,s,i,n])})))}entries(){return this._entries}*[Symbol.iterator](){for(const t of this._entries)yield t}}class pt{static wrap({type:t,object:e}){return d.concat([d.from(`${t} ${e.byteLength.toString()}\0`),d.from(e)])}static unwrap(t){const e=t.indexOf(32),r=t.indexOf(0),s=t.slice(0,e).toString("utf8"),i=t.slice(e+1,r).toString("utf8"),n=t.length-(r+1);if(parseInt(i)!==n)throw new u(`Length mismatch: expected ${i} bytes but got ${n} instead.`);return{type:s,object:d.from(t.slice(r+1))}}}function mt(t){let e=0,r=0,s=null;do{s=t.readUInt8(),e|=(127&s)<<r,r+=7}while(128&s);return e}function wt(t,e,r){let s=0,i=0;for(;r--;)1&e&&(s|=t.readUInt8()<<i),e>>=1,i+=8;return s}function gt(t,e){const r=t.readUInt8();if(128&r){const s=wt(t,15&r,4);let i=wt(t,(112&r)>>4,3);return 0===i&&(i=65536),e.slice(s,s+i)}return t.slice(r)}function yt(t){return t[Symbol.asyncIterator]?t[Symbol.asyncIterator]():t[Symbol.iterator]?t[Symbol.iterator]():t.next?t:function(t){let e=[t];return{next:()=>Promise.resolve({done:0===e.length,value:e.pop()}),return:()=>(e=[],{}),[Symbol.asyncIterator](){return this}}}(t)}class bt{constructor(t){this.stream=yt(t),this.buffer=null,this.cursor=0,this.undoCursor=0,this.started=!1,this._ended=!1,this._discardedBytes=0}eof(){return this._ended&&this.cursor===this.buffer.length}tell(){return this._discardedBytes+this.cursor}async byte(){if(!this.eof()&&(this.started||await this._init(),this.cursor!==this.buffer.length||(await this._loadnext(),!this._ended)))return this._moveCursor(1),this.buffer[this.undoCursor]}async chunk(){if(!this.eof()&&(this.started||await this._init(),this.cursor!==this.buffer.length||(await this._loadnext(),!this._ended)))return this._moveCursor(this.buffer.length),this.buffer.slice(this.undoCursor,this.cursor)}async read(t){if(!this.eof())return this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t),this.buffer.slice(this.undoCursor,this.cursor)}async skip(t){this.eof()||(this.started||await this._init(),this.cursor+t>this.buffer.length&&(this._trim(),await this._accumulate(t)),this._moveCursor(t))}async undo(){this.cursor=this.undoCursor}async _next(){this.started=!0;let{done:t,value:e}=await this.stream.next();return t&&(this._ended=!0),e&&(e=d.from(e)),e}_trim(){this.buffer=this.buffer.slice(this.undoCursor),this.cursor-=this.undoCursor,this._discardedBytes+=this.undoCursor,this.undoCursor=0}_moveCursor(t){this.undoCursor=this.cursor,this.cursor+=t,this.cursor>this.buffer.length&&(this.cursor=this.buffer.length)}async _accumulate(t){if(this._ended)return;const e=[this.buffer];for(;this.cursor+t>_t(e);){const t=await this._next();if(this._ended)break;e.push(t)}this.buffer=d.concat(e)}async _loadnext(){this._discardedBytes+=this.buffer.length,this.undoCursor=0,this.cursor=0,this.buffer=await this._next()}async _init(){this.buffer=await this._next()}}function _t(t){return t.reduce(((t,e)=>t+e.length),0)}async function $t(t){let e=await t.byte();const r=e>>4&7;let s,i,n=15&e;if(128&e){let r=4;do{e=await t.byte(),n|=(127&e)<<r,r+=7}while(128&e)}if(6===r){let r=0;s=0;const n=[];do{e=await t.byte(),s|=(127&e)<<r,r+=7,n.push(e)}while(128&e);i=d.from(n)}if(7===r){i=await t.read(20)}return{type:r,length:n,ofs:s,reference:i}}let xt=!1;async function Et(t){return null===xt&&(xt=function(){try{if(new DecompressionStream("deflate"))return!0}catch(t){}return!1}()),xt?async function(t){const e=new DecompressionStream("deflate"),r=new Blob([t]).stream().pipeThrough(e);return new Uint8Array(await new Response(r).arrayBuffer())}(t):a.inflate(t)}class vt{constructor(t){Object.assign(this,t),this.offsetCache={}}static async fromIdx({idx:t,getExternalRefDelta:e}){const r=new p(t);if("ff744f63"!==r.slice(4).toString("hex"))return;const s=r.readUInt32BE();if(2!==s)throw new u(`Unable to read version ${s} packfile IDX. (Only version 2 supported)`);if(t.byteLength>2147483648)throw new u("To keep implementation simple, I haven't implemented the layer 5 feature needed to support packfiles > 2GB in size.");r.seek(r.tell()+1020);const i=r.readUInt32BE(),n=[];for(let c=0;c<i;c++){const t=r.slice(20).toString("hex");n[c]=t}r.seek(r.tell()+4*i);const a=new Map;for(let c=0;c<i;c++)a.set(n[c],r.readUInt32BE());const o=r.slice(20).toString("hex");return new vt({hashes:n,crcs:{},offsets:a,packfileSha:o,getExternalRefDelta:e})}static async fromPack({pack:t,getExternalRefDelta:e,onProgress:r}){const s={1:"commit",2:"tree",3:"blob",4:"tag",6:"ofs-delta",7:"ref-delta"},i={},o=t.slice(-20).toString("hex"),c=[],d={},l=new Map;let f=null,h=null;await async function(t,e){const r=new bt(t);let s=await r.read(4);if(s=s.toString("utf8"),"PACK"!==s)throw new u(`Invalid PACK header '${s}'`);let i=await r.read(4);if(i=i.readUInt32BE(0),2!==i)throw new u(`Invalid packfile version: ${i}`);let n=await r.read(4);if(n=n.readUInt32BE(0),!(n<1))for(;!r.eof()&&n--;){const t=r.tell(),{type:s,length:i,ofs:o,reference:c}=await $t(r),d=new a.Inflate;for(;!d.result;){const a=await r.chunk();if(!a)break;if(d.push(a,!1),d.err)throw new u(`Pako error: ${d.msg}`);if(d.result){if(d.result.length!==i)throw new u("Inflated object size is different from that stated in packfile.");await r.undo(),await r.read(a.length-d.strm.avail_in);const l=r.tell();await e({data:d.result,type:s,num:n,offset:t,end:l,reference:c,ofs:o})}}}}([t],(async({data:t,type:e,reference:n,offset:a,num:o})=>{null===f&&(f=o);const c=Math.floor(100*(f-o)/f);c!==h&&r&&await r({phase:"Receiving objects",loaded:f-o,total:f}),h=c,(["commit","tree","blob","tag"].includes(e=s[e])||"ofs-delta"===e||"ref-delta"===e)&&(i[a]={type:e,offset:a})}));const p=Object.keys(i).map(Number);for(const[a,u]of p.entries()){const e=a+1===p.length?t.byteLength-20:p[a+1],r=i[u],s=n.buf(t.slice(u,e))>>>0;r.end=e,r.crc=s}const m=new vt({pack:Promise.resolve(t),packfileSha:o,crcs:d,hashes:c,offsets:l,getExternalRefDelta:e});h=null;let w=0;const g=[0,0,0,0,0,0,0,0,0,0,0,0];for(let n in i){n=Number(n);const t=Math.floor(100*w/f);t!==h&&r&&await r({phase:"Resolving deltas",loaded:w,total:f}),w++,h=t;const e=i[n];if(!e.oid)try{m.readDepth=0,m.externalReadDepth=0;const{type:t,object:r}=await m.readSlice({start:n});g[m.readDepth]+=1;const s=await x(pt.wrap({type:t,object:r}));e.oid=s,c.push(s),l.set(s,n),d[s]=e.crc}catch(y){continue}}return c.sort(),m}async toBuffer(){const t=[],e=(e,r)=>{t.push(d.from(e,r))};e("ff744f63","hex"),e("00000002","hex");const r=new p(d.alloc(1024));for(let c=0;c<256;c++){let t=0;for(const e of this.hashes)parseInt(e.slice(0,2),16)<=c&&t++;r.writeUInt32BE(t)}t.push(r.buffer);for(const c of this.hashes)e(c,"hex");const s=new p(d.alloc(4*this.hashes.length));for(const c of this.hashes)s.writeUInt32BE(this.crcs[c]);t.push(s.buffer);const i=new p(d.alloc(4*this.hashes.length));for(const c of this.hashes)i.writeUInt32BE(this.offsets.get(c));t.push(i.buffer),e(this.packfileSha,"hex");const n=d.concat(t),a=await x(n),o=d.alloc(20);return o.write(a,"hex"),d.concat([n,o])}async load({pack:t}){this.pack=t}async unload(){this.pack=null}async read({oid:t}){if(!this.offsets.get(t)){if(this.getExternalRefDelta)return this.externalReadDepth++,this.getExternalRefDelta(t);throw new u(`Could not read object ${t} from packfile`)}const e=this.offsets.get(t);return this.readSlice({start:e})}async readSlice({start:t}){if(this.offsetCache[t])return Object.assign({},this.offsetCache[t]);this.readDepth++;if(!this.pack)throw new u("Tried to read from a GitPackIndex with no packfile loaded into memory");const e=(await this.pack).slice(t),r=new p(e),s=r.readUInt8(),i=112&s;let n={16:"commit",32:"tree",48:"blob",64:"tag",96:"ofs_delta",112:"ref_delta"}[i];if(void 0===n)throw new u("Unrecognized type: 0b"+i.toString(2));const a=15&s;let o=a;128&s&&(o=function(t,e){let r=e,s=4,i=null;do{i=t.readUInt8(),r|=(127&i)<<s,s+=7}while(128&i);return r}(r,a));let c=null,l=null;if("ofs_delta"===n){const e=function(t){const e=[];let r=0,s=0;do{r=t.readUInt8();const i=127&r;e.push(i),s=128&r}while(s);return e.reduce(((t,e)=>t+1<<7|e),-1)}(r),s=t-e;({object:c,type:n}=await this.readSlice({start:s}))}if("ref_delta"===n){const t=r.slice(20).toString("hex");({object:c,type:n}=await this.read({oid:t}))}const f=e.slice(r.tell());if(l=d.from(await Et(f)),l.byteLength!==o)throw new u(`Packfile told us object would have length ${o} but it had length ${l.byteLength}`);return c&&(l=d.from(function(t,e){const r=new p(t),s=mt(r);if(s!==e.byteLength)throw new u(`applyDelta expected source buffer to be ${s} bytes but the provided buffer was ${e.length} bytes`);const i=mt(r);let n;const a=gt(r,e);if(a.byteLength===i)n=a;else{n=d.alloc(i);const t=new p(n);for(t.copy(a);!r.eof();)t.copy(gt(r,e));const s=t.tell();if(i!==s)throw new u(`applyDelta expected target buffer to be ${i} bytes but the resulting buffer was ${s} bytes`)}return n}(l,c))),this.readDepth>3&&(this.offsetCache[t]={type:n,object:l}),{type:n,format:"content",object:l}}}const kt=Symbol("PackfileCache");function St({fs:t,cache:e,filename:r,getExternalRefDelta:s,emitter:i,emitterPrefix:n}){e[kt]||(e[kt]=new Map);let a=e[kt].get(r);return a||(a=async function({fs:t,filename:e,getExternalRefDelta:r,emitter:s,emitterPrefix:i}){const n=await t.read(e);return vt.fromIdx({idx:n,getExternalRefDelta:r})}({fs:t,filename:r,getExternalRefDelta:s,emitter:i,emitterPrefix:n}),e[kt].set(r,a)),a}async function Pt({fs:t,cache:e,gitdir:r,oid:s,format:i="content"}){const n=s=>Pt({fs:t,cache:e,gitdir:r,oid:s});let a;if("4b825dc642cb6eb9a060e54bf8d69288fbee4904"===s&&(a={format:"wrapped",object:d.from("tree 0\0")}),a||(a=await async function({fs:t,gitdir:e,oid:r}){const s=`objects/${r.slice(0,2)}/${r.slice(2)}`,i=await t.read(`${e}/${s}`);return i?{object:i,format:"deflated",source:s}:null}({fs:t,gitdir:r,oid:s})),a||(a=await async function({fs:t,cache:e,gitdir:r,oid:s,format:i="content",getExternalRefDelta:n}){let a=await t.readdir(W(r,"objects/pack"));a=a.filter((t=>t.endsWith(".idx")));for(const o of a){const i=`${r}/objects/pack/${o}`,a=await St({fs:t,cache:e,filename:i,getExternalRefDelta:n});if(a.error)throw new u(a.error);if(a.offsets.has(s)){if(!a.pack){const e=i.replace(/idx$/,"pack");a.pack=t.read(e)}const e=await a.read({oid:s,getExternalRefDelta:n});return e.format="content",e.source=`objects/pack/${o.replace(/idx$/,"pack")}`,e}}return null}({fs:t,cache:e,gitdir:r,oid:s,getExternalRefDelta:n})),!a)throw new B(s);if("deflated"===i)return a;if("deflated"===a.format&&(a.object=d.from(await Et(a.object)),a.format="wrapped"),"wrapped"===a.format){if("wrapped"===i&&"wrapped"===a.format)return a;const t=await x(a.object);if(t!==s)throw new u(`SHA check failed! Expected ${s}, computed ${t}`);const{object:e,type:r}=pt.unwrap(a.object);a.type=r,a.object=e,a.format="content"}if("content"===a.format)return"content"===i?a:void 0;throw new u(`invalid format "${a.format}"`)}class It extends l{constructor(t,e,r=!0){super(`Failed to create ${t} at ${e} because it already exists.${r?` (Hint: use 'force: true' parameter to overwrite existing ${t}.)`:""}`),this.code=this.name=It.code,this.data={noun:t,where:e,canForce:r}}}It.code="AlreadyExistsError";class At extends l{constructor(t,e,r){super(`Found multiple ${t} matching "${e}" (${r.join(", ")}). Use a longer abbreviation length to disambiguate them.`),this.code=this.name=At.code,this.data={nouns:t,short:e,matches:r}}}At.code="AmbiguousError";class jt extends l{constructor(t){super(`Your local changes to the following files would be overwritten by checkout: ${t.join(", ")}`),this.code=this.name=jt.code,this.data={filepaths:t}}}jt.code="CheckoutConflictError";class Ut extends l{constructor(t,e){super(`Failed to checkout "${t}" because commit ${e} is not available locally. Do a git fetch to make the branch available locally.`),this.code=this.name=Ut.code,this.data={ref:t,oid:e}}}Ut.code="CommitNotFetchedError";class Ct extends l{constructor(){super("Empty response from git server."),this.code=this.name=Ct.code,this.data={}}}Ct.code="EmptyServerResponseError";class Rt extends l{constructor(){super("A simple fast-forward merge was not possible."),this.code=this.name=Rt.code,this.data={}}}Rt.code="FastForwardError";class Ot extends l{constructor(t,e){super(`One or more branches were not updated: ${t}`),this.code=this.name=Ot.code,this.data={prettyDetails:t,result:e}}}Ot.code="GitPushError";class Bt extends l{constructor(t,e,r){super(`HTTP Error: ${t} ${e}`),this.code=this.name=Bt.code,this.data={statusCode:t,statusMessage:e,response:r}}}Bt.code="HttpError";class Nt extends l{constructor(t){let e="invalid filepath";"leading-slash"===t||"trailing-slash"===t?e='"filepath" parameter should not include leading or trailing directory separators because these can cause problems on some platforms.':"directory"===t&&(e='"filepath" should not be a directory.'),super(e),this.code=this.name=Nt.code,this.data={reason:t}}}Nt.code="InvalidFilepathError";class Dt extends l{constructor(t,e){super(`"${t}" would be an invalid git reference. (Hint: a valid alternative would be "${e}".)`),this.code=this.name=Dt.code,this.data={ref:t,suggestion:e}}}Dt.code="InvalidRefNameError";class Tt extends l{constructor(t){super(`Maximum search depth of ${t} exceeded.`),this.code=this.name=Tt.code,this.data={depth:t}}}Tt.code="MaxDepthError";class Mt extends l{constructor(){super("Merges with conflicts are not supported yet."),this.code=this.name=Mt.code,this.data={}}}Mt.code="MergeNotSupportedError";class Ht extends l{constructor(t){super(`Automatic merge failed with one or more merge conflicts in the following files: ${t.toString()}. Fix conflicts then commit the result.`),this.code=this.name=Ht.code,this.data={filepaths:t}}}Ht.code="MergeConflictError";class Gt extends l{constructor(t){super(`No name was provided for ${t} in the argument or in the .git/config file.`),this.code=this.name=Gt.code,this.data={role:t}}}Gt.code="MissingNameError";class zt extends l{constructor(t){super(`The function requires a "${t}" parameter but none was provided.`),this.code=this.name=zt.code,this.data={parameter:t}}}zt.code="MissingParameterError";class Ft extends l{constructor(t){super('There are multiple errors that were thrown by the method. Please refer to the "errors" property to see more'),this.code=this.name=Ft.code,this.data={errors:t},this.errors=t}}Ft.code="MultipleGitError";class Wt extends l{constructor(t,e){super(`Expected "${t}" but received "${e}".`),this.code=this.name=Wt.code,this.data={expected:t,actual:e}}}Wt.code="ParseError";class qt extends l{constructor(t){let e="";"not-fast-forward"===t?e=" because it was not a simple fast-forward":"tag-exists"===t&&(e=" because tag already exists"),super(`Push rejected${e}. Use "force: true" to override.`),this.code=this.name=qt.code,this.data={reason:t}}}qt.code="PushRejectedError";class Lt extends l{constructor(t,e){super(`Remote does not support the "${t}" so the "${e}" parameter cannot be used.`),this.code=this.name=Lt.code,this.data={capability:t,parameter:e}}}Lt.code="RemoteCapabilityError";class Vt extends l{constructor(t,e){super(`Remote did not reply using the "smart" HTTP protocol. Expected "001e# service=git-upload-pack" but received: ${t}`),this.code=this.name=Vt.code,this.data={preview:t,response:e}}}Vt.code="SmartHttpError";class Kt extends l{constructor(t,e,r){super(`Git remote "${t}" uses an unrecognized transport protocol: "${e}"`),this.code=this.name=Kt.code,this.data={url:t,transport:e,suggestion:r}}}Kt.code="UnknownTransportError";class Zt extends l{constructor(t){super(`Cannot parse remote URL: "${t}"`),this.code=this.name=Zt.code,this.data={url:t}}}Zt.code="UrlParseError";class Yt extends l{constructor(){super("The operation was canceled."),this.code=this.name=Yt.code,this.data={}}}Yt.code="UserCanceledError";class Jt extends l{constructor(t){super(`Could not merge index: Entry for '${t}' is not up to date. Either reset the index entry to HEAD, or stage your unstaged chages.`),this.code=this.name=Jt.code,this.data={filepath:t}}}Jt.code="IndexResetError";function Xt({name:t,email:e,timestamp:r,timezoneOffset:s}){return`${t} <${e}> ${r} ${s=function(t){const e=function(t){return Math.sign(t)||(Object.is(t,-0)?-1:1)}((r=t,0===r?r:-r));var r;t=Math.abs(t);const s=Math.floor(t/60);t-=60*s;let i=String(s),n=String(t);i.length<2&&(i="0"+i);n.length<2&&(n="0"+n);return(-1===e?"-":"+")+i+n}(s)}`}function Qt(t){return t=(t=(t=t.replace(/\r/g,"")).replace(/^\n+/,"")).replace(/\n+$/,"")+"\n"}function te(t){const[,e,r,s,i]=t.match(/^(.*) <(.*)> (.*) (.*)$/);return{name:e,email:r,timestamp:Number(s),timezoneOffset:ee(i)}}function ee(t){let[,e,r,s]=t.match(/(\+|-)(\d\d)(\d\d)/);return s=("+"===e?1:-1)*(60*Number(r)+Number(s)),0===(i=s)?i:-i;var i}class re{constructor(t){if("string"===typeof t)this._tag=t;else if(d.isBuffer(t))this._tag=t.toString("utf8");else{if("object"!==typeof t)throw new u("invalid type passed to GitAnnotatedTag constructor");this._tag=re.render(t)}}static from(t){return new re(t)}static render(t){return`object ${t.object}\ntype ${t.type}\ntag ${t.tag}\ntagger ${Xt(t.tagger)}\n\n${t.message}\n${t.gpgsig?t.gpgsig:""}`}justHeaders(){return this._tag.slice(0,this._tag.indexOf("\n\n"))}message(){const t=this.withoutSignature();return t.slice(t.indexOf("\n\n")+2)}parse(){return Object.assign(this.headers(),{message:this.message(),gpgsig:this.gpgsig()})}render(){return this._tag}headers(){const t=this.justHeaders().split("\n"),e=[];for(const s of t)" "===s[0]?e[e.length-1]+="\n"+s.slice(1):e.push(s);const r={};for(const s of e){const t=s.slice(0,s.indexOf(" ")),e=s.slice(s.indexOf(" ")+1);Array.isArray(r[t])?r[t].push(e):r[t]=e}return r.tagger&&(r.tagger=te(r.tagger)),r.committer&&(r.committer=te(r.committer)),r}withoutSignature(){const t=Qt(this._tag);return-1===t.indexOf("\n-----BEGIN PGP SIGNATURE-----")?t:t.slice(0,t.lastIndexOf("\n-----BEGIN PGP SIGNATURE-----"))}gpgsig(){if(-1===this._tag.indexOf("\n-----BEGIN PGP SIGNATURE-----"))return;return Qt(this._tag.slice(this._tag.indexOf("-----BEGIN PGP SIGNATURE-----"),this._tag.indexOf("-----END PGP SIGNATURE-----")+"-----END PGP SIGNATURE-----".length))}payload(){return this.withoutSignature()+"\n"}toObject(){return d.from(this._tag,"utf8")}static async sign(t,e,r){const s=t.payload();let{signature:i}=await e({payload:s,secretKey:r});i=Qt(i);const n=s+i;return re.from(n)}}function se(t){return t.trim().split("\n").map((t=>" "+t)).join("\n")+"\n"}class ie{constructor(t){if("string"===typeof t)this._commit=t;else if(d.isBuffer(t))this._commit=t.toString("utf8");else{if("object"!==typeof t)throw new u("invalid type passed to GitCommit constructor");this._commit=ie.render(t)}}static fromPayloadSignature({payload:t,signature:e}){const r=ie.justHeaders(t),s=ie.justMessage(t),i=Qt(r+"\ngpgsig"+se(e)+"\n"+s);return new ie(i)}static from(t){return new ie(t)}toObject(){return d.from(this._commit,"utf8")}headers(){return this.parseHeaders()}message(){return ie.justMessage(this._commit)}parse(){return Object.assign({message:this.message()},this.headers())}static justMessage(t){return Qt(t.slice(t.indexOf("\n\n")+2))}static justHeaders(t){return t.slice(0,t.indexOf("\n\n"))}parseHeaders(){const t=ie.justHeaders(this._commit).split("\n"),e=[];for(const s of t)" "===s[0]?e[e.length-1]+="\n"+s.slice(1):e.push(s);const r={parent:[]};for(const s of e){const t=s.slice(0,s.indexOf(" ")),e=s.slice(s.indexOf(" ")+1);Array.isArray(r[t])?r[t].push(e):r[t]=e}return r.author&&(r.author=te(r.author)),r.committer&&(r.committer=te(r.committer)),r}static renderHeaders(t){let e="";if(t.tree?e+=`tree ${t.tree}\n`:e+="tree 4b825dc642cb6eb9a060e54bf8d69288fbee4904\n",t.parent){if(void 0===t.parent.length)throw new u("commit 'parent' property should be an array");for(const r of t.parent)e+=`parent ${r}\n`}e+=`author ${Xt(t.author)}\n`;return e+=`committer ${Xt(t.committer||t.author)}\n`,t.gpgsig&&(e+="gpgsig"+se(t.gpgsig)),e}static render(t){return ie.renderHeaders(t)+"\n"+Qt(t.message)}render(){return this._commit}withoutSignature(){const t=Qt(this._commit);if(-1===t.indexOf("\ngpgsig"))return t;return Qt(t.slice(0,t.indexOf("\ngpgsig"))+"\n"+t.slice(t.indexOf("-----END PGP SIGNATURE-----\n")+"-----END PGP SIGNATURE-----\n".length))}isolateSignature(){const t=this._commit.slice(this._commit.indexOf("-----BEGIN PGP SIGNATURE-----"),this._commit.indexOf("-----END PGP SIGNATURE-----")+"-----END PGP SIGNATURE-----".length);return t.split("\n").map((t=>t.replace(/^ /,""))).join("\n")}static async sign(t,e,r){const s=t.withoutSignature(),i=ie.justMessage(t._commit);let{signature:n}=await e({payload:s,secretKey:r});n=Qt(n);const a=ie.justHeaders(t._commit)+"\ngpgsig"+se(n)+"\n"+i;return ie.from(a)}}async function ne({fs:t,cache:e,gitdir:r,oid:s}){if("4b825dc642cb6eb9a060e54bf8d69288fbee4904"===s)return{tree:ht.from([]),oid:s};const{type:i,object:n}=await Pt({fs:t,cache:e,gitdir:r,oid:s});if("tag"===i)return ne({fs:t,cache:e,gitdir:r,oid:s=re.from(n).parse().object});if("commit"===i)return ne({fs:t,cache:e,gitdir:r,oid:s=ie.from(n).parse().tree});if("tree"!==i)throw new N(s,i,"tree");return{tree:ht.from(n),oid:s}}class ae{constructor({fs:t,gitdir:e,ref:r,cache:s}){this.fs=t,this.cache=s,this.gitdir=e,this.mapPromise=(async()=>{const s=new Map;let i;try{i=await ct.resolve({fs:t,gitdir:e,ref:r})}catch(a){a instanceof B&&(i="4b825dc642cb6eb9a060e54bf8d69288fbee4904")}const n=await ne({fs:t,cache:this.cache,gitdir:e,oid:i});return n.type="tree",n.mode="40000",s.set(".",n),s})();const i=this;this.ConstructEntry=class{constructor(t){this._fullpath=t,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return i.type(this)}async mode(){return i.mode(this)}async stat(){return i.stat(this)}async content(){return i.content(this)}async oid(){return i.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:r,cache:s,gitdir:i}=this,n=await this.mapPromise,a=n.get(e);if(!a)throw new Error(`No obj for ${e}`);const o=a.oid;if(!o)throw new Error(`No oid for obj ${JSON.stringify(a)}`);if("tree"!==a.type)return null;const{type:c,object:d}=await Pt({fs:r,cache:s,gitdir:i,oid:o});if(c!==a.type)throw new N(o,c,a.type);const l=ht.from(d);for(const f of l)n.set(W(e,f.path),f);return l.entries().map((t=>W(e,t.path)))}async type(t){if(!1===t._type){const e=await this.mapPromise,{type:r}=e.get(t._fullpath);t._type=r}return t._type}async mode(t){if(!1===t._mode){const e=await this.mapPromise,{mode:r}=e.get(t._fullpath);t._mode=g(parseInt(r,8))}return t._mode}async stat(t){}async content(t){if(!1===t._content){const e=await this.mapPromise,{fs:r,cache:s,gitdir:i}=this,n=e.get(t._fullpath).oid,{type:a,object:o}=await Pt({fs:r,cache:s,gitdir:i,oid:n});t._content="blob"!==a?void 0:new Uint8Array(o)}return t._content}async oid(t){if(!1===t._oid){const e=(await this.mapPromise).get(t._fullpath);t._oid=e.oid}return t._oid}}function oe({ref:t="HEAD"}={}){const e=Object.create(null);return Object.defineProperty(e,R,{value:function({fs:e,gitdir:r,cache:s}){return new ae({fs:e,gitdir:r,ref:t,cache:s})}}),Object.freeze(e),e}class ce{constructor({fs:t,dir:e,gitdir:r,cache:s}){this.fs=t,this.cache=s,this.dir=e,this.gitdir=r;const i=this;this.ConstructEntry=class{constructor(t){this._fullpath=t,this._type=!1,this._mode=!1,this._stat=!1,this._content=!1,this._oid=!1}async type(){return i.type(this)}async mode(){return i.mode(this)}async stat(){return i.stat(this)}async content(){return i.content(this)}async oid(){return i.oid(this)}}}async readdir(t){const e=t._fullpath,{fs:r,dir:s}=this,i=await r.readdir(W(s,e));return null===i?null:i.map((t=>W(e,t)))}async type(t){return!1===t._type&&await t.stat(),t._type}async mode(t){return!1===t._mode&&await t.stat(),t._mode}async stat(t){if(!1===t._stat){const{fs:e,dir:r}=this;let s=await e.lstat(`${r}/${t._fullpath}`);if(!s)throw new Error(`ENOENT: no such file or directory, lstat '${t._fullpath}'`);let i=s.isDirectory()?"tree":"blob";"blob"!==i||s.isFile()||s.isSymbolicLink()||(i="special"),t._type=i,s=_(s),t._mode=s.mode,-1===s.size&&t._actualSize&&(s.size=t._actualSize),t._stat=s}return t._stat}async content(t){if(!1===t._content){const{fs:e,dir:r}=this;if("tree"===await t.type())t._content=void 0;else{const s=await e.read(`${r}/${t._fullpath}`);t._actualSize=s.length,t._stat&&-1===t._stat.size&&(t._stat.size=t._actualSize),t._content=new Uint8Array(s)}}return t._content}async oid(t){if(!1===t._oid){const{fs:e,gitdir:r,cache:s}=this;let i;await I.acquire({fs:e,gitdir:r,cache:s},(async function(e){const r=e.entriesMap.get(t._fullpath),s=await t.stat();if(!r||k(s,r)){void 0===await t.content()?i=void 0:(i=await x(pt.wrap({type:"blob",object:await t.content()})),r&&i===r.oid&&s.mode===r.mode&&k(s,r)&&e.insert({filepath:t._fullpath,stats:s,oid:i}))}else i=r.oid})),t._oid=i}return t._oid}}function de(){const t=Object.create(null);return Object.defineProperty(t,R,{value:function({fs:t,dir:e,gitdir:r,cache:s}){return new ce({fs:t,dir:e,gitdir:r,cache:s})}}),Object.freeze(t),t}const le="undefined"===typeof Array.prototype.flat?t=>t.reduce(((t,e)=>t.concat(e)),[]):t=>t.flat();class fe{constructor(){this.value=null}consider(t){null!==t&&void 0!==t&&(null===this.value||t<this.value)&&(this.value=t)}reset(){this.value=null}}function*ue(t){const e=new fe;let r;const s=[],i=t.length;for(let n=0;n<i;n++)s[n]=t[n].next().value,void 0!==s[n]&&e.consider(s[n]);if(null!==e.value)for(;;){const n=[];r=e.value,e.reset();for(let a=0;a<i;a++)void 0!==s[a]&&s[a]===r?(n[a]=s[a],s[a]=t[a].next().value):n[a]=null,void 0!==s[a]&&e.consider(s[a]);if(yield n,null===e.value)return}}async function he({fs:t,cache:e,dir:r,gitdir:s,trees:i,map:n=(async(t,e)=>e),reduce:a=(async(t,e)=>{const r=le(e);return void 0!==t&&r.unshift(t),r}),iterate:o=((t,e)=>Promise.all([...e].map(t)))}){const c=i.map((i=>i[R]({fs:t,dir:r,gitdir:s,cache:e}))),d=new Array(c.length).fill("."),l=function(t,e){const r=e-t;return Array.from({length:r},((e,r)=>t+r))}(0,c.length),f=async t=>{const{entries:e,children:r}=await(async t=>{l.map((e=>{t[e]=t[e]&&new c[e].ConstructEntry(t[e])}));const e=(await Promise.all(l.map((e=>t[e]?c[e].readdir(t[e]):[])))).map((t=>null===t?[]:t)).map((t=>t[Symbol.iterator]()));return{entries:t,children:ue(e)}})(t),s=e.find((t=>t&&t._fullpath))._fullpath,i=await n(s,e);if(null!==i){let t=await o(f,r);return t=t.filter((t=>void 0!==t)),a(i,t)}};return f(d)}async function pe(t,e){const r=await t.readdir(e);null==r?await t.rm(e):r.length?await Promise.all(r.map((r=>{const s=W(e,r);return t.lstat(s).then((e=>{if(e)return e.isDirectory()?pe(t,s):t.rm(s)}))}))).then((()=>t.rmdir(e))):await t.rmdir(e)}function me(t){return"Promise"===(t=>{try{return t.readFile().catch((t=>t))}catch(e){return e}})(t).constructor.name}const we=["readFile","writeFile","mkdir","rmdir","unlink","stat","lstat","readdir","readlink","symlink"];function ge(t,e){if(me(e))for(const r of we)t[`_${r}`]=e[r].bind(e);else for(const r of we)t[`_${r}`]=o(e[r].bind(e));me(e)?e.rm?t._rm=e.rm.bind(e):e.rmdir.length>1?t._rm=e.rmdir.bind(e):t._rm=pe.bind(null,t):e.rm?t._rm=o(e.rm.bind(e)):e.rmdir.length>2?t._rm=o(e.rmdir.bind(e)):t._rm=pe.bind(null,t)}class ye{constructor(t){if("undefined"!==typeof t._original_unwrapped_fs)return t;const e=Object.getOwnPropertyDescriptor(t,"promises");e&&e.enumerable?ge(this,t.promises):ge(this,t),this._original_unwrapped_fs=t}async exists(t,e={}){try{return await this._stat(t),!0}catch(r){if("ENOENT"===r.code||"ENOTDIR"===r.code)return!1;throw console.log('Unhandled error in "FileSystem.exists()" function',r),r}}async read(t,e={}){try{let r=await this._readFile(t,e);return"string"!==typeof r&&(r=d.from(r)),r}catch(r){return null}}async write(t,e,r={}){try{return void(await this._writeFile(t,e,r))}catch(s){await this.mkdir(j(t)),await this._writeFile(t,e,r)}}async mkdir(t,e=!1){try{return void(await this._mkdir(t))}catch(r){if(null===r)return;if("EEXIST"===r.code)return;if(e)throw r;if("ENOENT"===r.code){const e=j(t);if("."===e||"/"===e||e===t)throw r;await this.mkdir(e),await this.mkdir(t,!0)}}}async rm(t){try{await this._unlink(t)}catch(e){if("ENOENT"!==e.code)throw e}}async rmdir(t,e){try{e&&e.recursive?await this._rm(t,e):await this._rmdir(t)}catch(r){if("ENOENT"!==r.code)throw r}}async readdir(t){try{const e=await this._readdir(t);return e.sort(m),e}catch(e){return"ENOTDIR"===e.code?null:[]}}async readdirDeep(t){const e=await this._readdir(t);return(await Promise.all(e.map((async e=>{const r=t+"/"+e;return(await this._stat(r)).isDirectory()?this.readdirDeep(r):r})))).reduce(((t,e)=>t.concat(e)),[])}async lstat(t){try{return await this._lstat(t)}catch(e){if("ENOENT"===e.code)return null;throw e}}async readlink(t,e={encoding:"buffer"}){try{const r=await this._readlink(t,e);return d.isBuffer(r)?r:d.from(r)}catch(r){if("ENOENT"===r.code)return null;throw r}}async writelink(t,e){return this._symlink(e.toString("utf8"),t)}}function be(t,e){if(void 0===e)throw new zt(t)}async function _e({fs:t,gitdir:e,remote:r,url:s,force:i}){if(r!==c.clean(r))throw new Dt(r,c.clean(r));const n=await nt.get({fs:t,gitdir:e});if(!i){if((await n.getSubsections("remote")).includes(r)&&s!==await n.get(`remote.${r}.url`))throw new It("remote",r)}await n.set(`remote.${r}.url`,s),await n.set(`remote.${r}.fetch`,`+refs/heads/*:refs/remotes/${r}/*`),await nt.save({fs:t,gitdir:e,config:n})}const $e=(t,e)=>"."===t||null==e||0===e.length||"."===e||(e.length>=t.length?e.startsWith(t):t.startsWith(e));async function xe({fs:t,cache:e,onProgress:r,dir:s,gitdir:i,remote:n,ref:a,filepaths:o,noCheckout:c,noUpdateHead:d,dryRun:l,force:f,track:h=!0}){let p;try{p=await ct.resolve({fs:t,gitdir:i,ref:a})}catch(m){if("HEAD"===a)throw m;const e=`${n}/${a}`;if(p=await ct.resolve({fs:t,gitdir:i,ref:e}),h){const e=await nt.get({fs:t,gitdir:i});await e.set(`branch.${a}.remote`,n),await e.set(`branch.${a}.merge`,`refs/heads/${a}`),await nt.save({fs:t,gitdir:i,config:e})}await ct.writeRef({fs:t,gitdir:i,ref:`refs/heads/${a}`,value:p})}if(!c){let n;try{n=await async function({fs:t,cache:e,onProgress:r,dir:s,gitdir:i,ref:n,force:a,filepaths:o}){let c=0;return he({fs:t,cache:e,dir:s,gitdir:i,trees:[oe({ref:n}),de(),O()],map:async function(t,[e,s,i]){if("."===t)return;if(o&&!o.some((e=>$e(t,e))))return null;r&&await r({phase:"Analyzing workdir",loaded:++c});switch([!!i,!!e,!!s].map(Number).join("")){case"000":return;case"001":return a&&o&&o.includes(t)?["delete",t]:void 0;case"010":switch(await e.type()){case"tree":return["mkdir",t];case"blob":return["create",t,await e.oid(),await e.mode()];case"commit":return["mkdir-index",t,await e.oid(),await e.mode()];default:return["error",`new entry Unhandled type ${await e.type()}`]}case"011":switch(`${await e.type()}-${await s.type()}`){case"tree-tree":case"commit-tree":return;case"tree-blob":case"blob-tree":case"commit-blob":return["conflict",t];case"blob-blob":return await e.oid()!==await s.oid()?a?["update",t,await e.oid(),await e.mode(),await e.mode()!==await s.mode()]:["conflict",t]:await e.mode()!==await s.mode()?a?["update",t,await e.oid(),await e.mode(),!0]:["conflict",t]:["create-index",t,await e.oid(),await e.mode()];default:return["error",`new entry Unhandled type ${e.type}`]}case"100":return["delete-index",t];case"101":switch(await i.type()){case"tree":return["rmdir",t];case"blob":return await i.oid()!==await s.oid()?a?["delete",t]:["conflict",t]:["delete",t];case"commit":return["rmdir-index",t];default:return["error",`delete entry Unhandled type ${await i.type()}`]}case"110":case"111":switch(`${await i.type()}-${await e.type()}`){case"tree-tree":return;case"blob-blob":if(await i.oid()===await e.oid()&&await i.mode()===await e.mode()&&!a)return;if(s){if(await s.oid()!==await i.oid()&&await s.oid()!==await e.oid())return a?["update",t,await e.oid(),await e.mode(),await e.mode()!==await s.mode()]:["conflict",t]}else if(a)return["update",t,await e.oid(),await e.mode(),await e.mode()!==await i.mode()];return await e.mode()!==await i.mode()?["update",t,await e.oid(),await e.mode(),!0]:await e.oid()!==await i.oid()?["update",t,await e.oid(),await e.mode(),!1]:void 0;case"tree-blob":return["update-dir-to-blob",t,await e.oid()];case"blob-tree":return["update-blob-to-tree",t];case"commit-commit":return["mkdir-index",t,await e.oid(),await e.mode()];default:return["error",`update entry Unhandled type ${await i.type()}-${await e.type()}`]}}},reduce:async function(t,e){return e=le(e),t?t&&"rmdir"===t[0]?(e.push(t),e):(e.unshift(t),e):e}})}({fs:t,cache:e,onProgress:r,dir:s,gitdir:i,ref:a,force:f,filepaths:o})}catch(m){throw m instanceof B&&m.data.what===p?new Ut(a,p):m}const c=n.filter((([t])=>"conflict"===t)).map((([t,e])=>e));if(c.length>0)throw new jt(c);const d=n.filter((([t])=>"error"===t)).map((([t,e])=>e));if(d.length>0)throw new u(d.join(", "));if(l)return;let h=0;const w=n.length;await I.acquire({fs:t,gitdir:i,cache:e},(async function(e){await Promise.all(n.filter((([t])=>"delete"===t||"delete-index"===t)).map((async function([i,n]){const a=`${s}/${n}`;"delete"===i&&await t.rm(a),e.delete({filepath:n}),r&&await r({phase:"Updating workdir",loaded:++h,total:w})})))})),await I.acquire({fs:t,gitdir:i,cache:e},(async function(e){for(const[a,o]of n)if("rmdir"===a||"rmdir-index"===a){const n=`${s}/${o}`;try{"rmdir-index"===a&&e.delete({filepath:o}),await t.rmdir(n),r&&await r({phase:"Updating workdir",loaded:++h,total:w})}catch(i){if("ENOTEMPTY"!==i.code)throw i;console.log(`Did not delete ${o} because directory is not empty`)}}})),await Promise.all(n.filter((([t])=>"mkdir"===t||"mkdir-index"===t)).map((async function([e,i]){const n=`${s}/${i}`;await t.mkdir(n),r&&await r({phase:"Updating workdir",loaded:++h,total:w})}))),await I.acquire({fs:t,gitdir:i,cache:e},(async function(a){await Promise.all(n.filter((([t])=>"create"===t||"create-index"===t||"update"===t||"mkdir-index"===t)).map((async function([n,o,c,d,l]){const f=`${s}/${o}`;try{if("create-index"!==n&&"mkdir-index"!==n){const{object:r}=await Pt({fs:t,cache:e,gitdir:i,oid:c});if(l&&await t.rm(f),33188===d)await t.write(f,r);else if(33261===d)await t.write(f,r,{mode:511});else{if(40960!==d)throw new u(`Invalid mode 0o${d.toString(8)} detected in blob ${c}`);await t.writelink(f,r)}}const s=await t.lstat(f);33261===d&&(s.mode=493),"mkdir-index"===n&&(s.mode=57344),a.insert({filepath:o,stats:s,oid:c}),r&&await r({phase:"Updating workdir",loaded:++h,total:w})}catch(p){console.log(p)}})))}))}if(!d){const e=await ct.expand({fs:t,gitdir:i,ref:a});e.startsWith("refs/heads")?await ct.writeSymbolicRef({fs:t,gitdir:i,ref:"HEAD",value:e}):await ct.writeRef({fs:t,gitdir:i,ref:"HEAD",value:p})}}async function Ee({fs:t,onProgress:e,dir:r,gitdir:s=W(r,".git"),remote:i="origin",ref:n,filepaths:a,noCheckout:o=!1,noUpdateHead:c=void 0===n,dryRun:d=!1,force:l=!1,track:f=!0,cache:u={}}){try{be("fs",t),be("dir",r),be("gitdir",s);const h=n||"HEAD";return await xe({fs:new ye(t),cache:u,onProgress:e,dir:r,gitdir:s,remote:i,ref:h,filepaths:a,noCheckout:o,noUpdateHead:c,dryRun:d,force:l,track:f})}catch(h){throw h.caller="git.checkout",h}}const ve=new RegExp("^refs/(heads/|tags/|remotes/)?(.*)");function ke(t){const e=ve.exec(t);return e?"remotes/"===e[1]&&t.endsWith("/HEAD")?e[2].slice(0,-5):e[2]:t}async function Se({fs:t,gitdir:e,fullname:r=!1,test:s=!1}){const i=await ct.resolve({fs:t,gitdir:e,ref:"HEAD",depth:2});if(s)try{await ct.resolve({fs:t,gitdir:e,ref:i})}catch(n){return}if(i.startsWith("refs/"))return r?i:ke(i)}function Pe({username:t="",password:e=""}){return`Basic ${d.from(`${t}:${e}`).toString("base64")}`}async function Ie(t,e){const r=yt(t);for(;;){const{value:t,done:s}=await r.next();if(t&&await e(t),s)break}r.return&&r.return()}async function Ae(t){let e=0;const r=[];await Ie(t,(t=>{r.push(t),e+=t.byteLength}));const s=new Uint8Array(e);let i=0;for(const n of r)s.set(n,i),i+=n.byteLength;return s}function je(t){let e=t.match(/^https?:\/\/([^/]+)@/);if(null==e)return{url:t,auth:{}};e=e[1];const[r,s]=e.split(":");return{url:t=t.replace(`${e}@`,""),auth:{username:r,password:s}}}function Ue(t,e){const r=e.toString(16);return"0".repeat(t-r.length)+r}class Ce{static flush(){return d.from("0000","utf8")}static delim(){return d.from("0001","utf8")}static encode(t){"string"===typeof t&&(t=d.from(t));const e=Ue(4,t.length+4);return d.concat([d.from(e,"utf8"),t])}static streamReader(t){const e=new bt(t);return async function(){try{let t=await e.read(4);if(null==t)return!0;if(t=parseInt(t.toString("utf8"),16),0===t)return null;if(1===t)return null;const r=await e.read(t-4);return null==r||r}catch(t){return console.log("error",t),!0}}}}async function Re(t){const e={};let r;for(;r=await t(),!0!==r;){if(null===r)continue;r=r.toString("utf8").replace(/\n$/,"");const t=r.indexOf("=");if(t>-1){const s=r.slice(0,t),i=r.slice(t+1);e[s]=i}else e[r]=!0}return{protocolVersion:2,capabilities2:e}}async function Oe(t,{service:e}){const r=new Set,s=new Map,i=new Map,n=Ce.streamReader(t);let a=await n();for(;null===a;)a=await n();if(!0===a)throw new Ct;if(a.includes("version 2"))return Re(n);if(a.toString("utf8").replace(/\n$/,"")!==`# service=${e}`)throw new Wt(`# service=${e}\\n`,a.toString("utf8"));let o=await n();for(;null===o;)o=await n();if(!0===o)return{capabilities:r,refs:s,symrefs:i};if(o=o.toString("utf8"),o.includes("version 2"))return Re(n);const[c,d]=Be(o,"\0","\\x00");d.split(" ").map((t=>r.add(t)));const[l,f]=Be(c," "," ");for(s.set(f,l);;){const t=await n();if(!0===t)break;if(null!==t){const[e,r]=Be(t.toString("utf8")," "," ");s.set(r,e)}}for(const u of r)if(u.startsWith("symref=")){const t=u.match(/symref=([^:]+):(.*)/);3===t.length&&i.set(t[1],t[2])}return{protocolVersion:1,capabilities:r,refs:s,symrefs:i}}function Be(t,e,r){const s=t.trim().split(e);if(2!==s.length)throw new Wt(`Two strings separated by '${r}'`,t.toString("utf8"));return s}const Ne=(t,e)=>t.endsWith("?")?`${t}${e}`:`${t}/${e.replace(/^https?:\/\//,"")}`,De=(t,e)=>{(e.username||e.password)&&(t.Authorization=Pe(e)),e.headers&&Object.assign(t,e.headers)},Te=async t=>{try{const e=d.from(await Ae(t.body)),r=e.toString("utf8");return{preview:r.length<256?r:r.slice(0,256)+"...",response:r,data:e}}catch(e){return{}}};class Me{static async capabilities(){return["discover","connect"]}static async discover({http:t,onProgress:e,onAuth:r,onAuthSuccess:s,onAuthFailure:i,corsProxy:n,service:a,url:o,headers:c,protocolVersion:d}){let{url:l,auth:f}=je(o);const u=n?Ne(n,l):l;let h,p;(f.username||f.password)&&(c.Authorization=Pe(f)),2===d&&(c["Git-Protocol"]="version=2");let m=!1;do{if(h=await t.request({onProgress:e,method:"GET",url:`${u}/info/refs?service=${a}`,headers:c}),p=!1,401===h.statusCode||203===h.statusCode){const t=m?i:r;if(t){if(f=await t(l,{...f,headers:{...c}}),f&&f.cancel)throw new Yt;f&&(De(c,f),m=!0,p=!0)}}else 200===h.statusCode&&m&&s&&await s(l,f)}while(p);if(200!==h.statusCode){const{response:t}=await Te(h);throw new Bt(h.statusCode,h.statusMessage,t)}if(h.headers["content-type"]===`application/x-${a}-advertisement`){const t=await Oe(h.body,{service:a});return t.auth=f,t}{const{preview:t,response:e,data:r}=await Te(h);try{const t=await Oe([r],{service:a});return t.auth=f,t}catch(w){throw new Vt(t,e)}}}static async connect({http:t,onProgress:e,corsProxy:r,service:s,url:i,auth:n,body:a,headers:o}){const c=je(i);c&&(i=c.url),r&&(i=Ne(r,i)),o["content-type"]=`application/x-${s}-request`,o.accept=`application/x-${s}-result`,De(o,n);const d=await t.request({onProgress:e,method:"POST",url:`${i}/${s}`,body:a,headers:o});if(200!==d.statusCode){const{response:t}=Te(d);throw new Bt(d.statusCode,d.statusMessage,t)}return d}}class He{static getRemoteHelperFor({url:t}){const e=new Map;e.set("http",Me),e.set("https",Me);const r=function({url:t}){if(t.startsWith("git@"))return{transport:"ssh",address:t};const e=t.match(/(\w+)(:\/\/|::)(.*)/);return null!==e?"://"===e[2]?{transport:e[1],address:e[0]}:"::"===e[2]?{transport:e[1],address:e[3]}:void 0:void 0}({url:t});if(!r)throw new Zt(t);if(e.has(r.transport))return e.get(r.transport);throw new Kt(t,r.transport,"ssh"===r.transport?function(t){return(t=t.replace(/^git@([^:]+):/,"https://$1/")).replace(/^ssh:\/\//,"https://")}(t):void 0)}}let Ge=null;class ze{static async read({fs:t,gitdir:e}){null===Ge&&(Ge=new s);const r=W(e,"shallow"),i=new Set;return await Ge.acquire(r,(async function(){const e=await t.read(r,{encoding:"utf8"});return null===e||""===e.trim()?i:void e.trim().split("\n").map((t=>i.add(t)))})),i}static async write({fs:t,gitdir:e,oids:r}){null===Ge&&(Ge=new s);const i=W(e,"shallow");if(r.size>0){const e=[...r].join("\n")+"\n";await Ge.acquire(i,(async function(){await t.write(i,e,{encoding:"utf8"})}))}else await Ge.acquire(i,(async function(){await t.rm(i)}))}}async function Fe({fs:t,cache:e,gitdir:r,oid:s,format:i="content"}){const n=s=>Pt({fs:t,cache:e,gitdir:r,oid:s});let a=await async function({fs:t,gitdir:e,oid:r}){const s=`objects/${r.slice(0,2)}/${r.slice(2)}`;return t.exists(`${e}/${s}`)}({fs:t,gitdir:r,oid:s});return a||(a=await async function({fs:t,cache:e,gitdir:r,oid:s,getExternalRefDelta:i}){let n=await t.readdir(W(r,"objects/pack"));n=n.filter((t=>t.endsWith(".idx")));for(const a of n){const n=`${r}/objects/pack/${a}`,o=await St({fs:t,cache:e,filename:n,getExternalRefDelta:i});if(o.error)throw new u(o.error);if(o.offsets.has(s))return!0}return!1}({fs:t,cache:e,gitdir:r,oid:s,getExternalRefDelta:n})),a}function We(t,e){const r=t.map((t=>t.split("=",1)[0]));return e.filter((t=>{const e=t.split("=",1)[0];return r.includes(e)}))}const qe="1.24.3",Le="git/isomorphic-git@1.24.3";class Ve{constructor(){this._queue=[]}write(t){if(this._ended)throw Error("You cannot write to a FIFO that has already been ended!");if(this._waiting){const e=this._waiting;this._waiting=null,e({value:t})}else this._queue.push(t)}end(){if(this._ended=!0,this._waiting){const t=this._waiting;this._waiting=null,t({done:!0})}}destroy(t){this._ended=!0,this.error=t}async next(){if(this._queue.length>0)return{value:this._queue.shift()};if(this._ended)return{done:!0};if(this._waiting)throw Error("You cannot call read until the previous call to read has returned!");return new Promise((t=>{this._waiting=t}))}}function Ke(t){const e=t.indexOf("\r"),r=t.indexOf("\n");return-1===e&&-1===r?-1:-1===e?r+1:-1===r?e+1:r===e+1?r+1:Math.min(e,r)+1}function Ze(t){const e=new Ve;let r="";return(async()=>{await Ie(t,(t=>{for(t=t.toString("utf8"),r+=t;;){const t=Ke(r);if(-1===t)break;e.write(r.slice(0,t)),r=r.slice(t)}})),r.length>0&&e.write(r),e.end()})(),e}class Ye{static demux(t){const e=Ce.streamReader(t),r=new Ve,s=new Ve,i=new Ve,n=async function(){const t=await e();if(null===t)return n();if(!0===t)return r.end(),i.end(),void s.end();switch(t[0]){case 1:s.write(t.slice(1));break;case 2:i.write(t.slice(1));break;case 3:{const e=t.slice(1);return i.write(e),void s.destroy(new Error(e.toString("utf8")))}default:r.write(t.slice(0))}n()};return n(),{packetlines:r,packfile:s,progress:i}}}async function Je({fs:t,cache:e,http:r,onProgress:s,onMessage:i,onAuth:n,onAuthSuccess:a,onAuthFailure:o,gitdir:c,ref:l,remoteRef:f,remote:u,url:h,corsProxy:p,depth:m=null,since:w=null,exclude:g=[],relative:y=!1,tags:b=!1,singleBranch:_=!1,headers:$={},prune:x=!1,pruneTags:E=!1}){const v=l||await Se({fs:t,gitdir:c,test:!0}),k=await nt.get({fs:t,gitdir:c}),S=u||v&&await k.get(`branch.${v}.remote`)||"origin",P=h||await k.get(`remote.${S}.url`);if("undefined"===typeof P)throw new zt("remote OR url");const I=f||v&&await k.get(`branch.${v}.merge`)||l||"HEAD";void 0===p&&(p=await k.get("http.corsProxy"));const A=He.getRemoteHelperFor({url:P}),j=await A.discover({http:r,onAuth:n,onAuthSuccess:a,onAuthFailure:o,corsProxy:p,service:"git-upload-pack",url:P,headers:$,protocolVersion:1}),U=j.auth,C=j.refs;if(0===C.size)return{defaultBranch:null,fetchHead:null,fetchHeadDescription:null};if(null!==m&&!j.capabilities.has("shallow"))throw new Lt("shallow","depth");if(null!==w&&!j.capabilities.has("deepen-since"))throw new Lt("deepen-since","since");if(g.length>0&&!j.capabilities.has("deepen-not"))throw new Lt("deepen-not","exclude");if(!0===y&&!j.capabilities.has("deepen-relative"))throw new Lt("deepen-relative","relative");const{oid:R,fullref:O}=ct.resolveAgainstMap({ref:I,map:C});for(const d of C.keys())d===O||"HEAD"===d||d.startsWith("refs/heads/")||b&&d.startsWith("refs/tags/")||C.delete(d);const B=We([...j.capabilities],["multi_ack_detailed","no-done","side-band-64k","ofs-delta",`agent=${Le}`]);y&&B.push("deepen-relative");const N=_?[R]:C.values(),T=_?[v]:await ct.listRefs({fs:t,gitdir:c,filepath:"refs"});let M=[];for(let d of T)try{d=await ct.expand({fs:t,gitdir:c,ref:d});const r=await ct.resolve({fs:t,gitdir:c,ref:d});await Fe({fs:t,cache:e,gitdir:c,oid:r})&&M.push(r)}catch(Y){}M=[...new Set(M)];const H=await ze.read({fs:t,gitdir:c}),G=function({capabilities:t=[],wants:e=[],haves:r=[],shallows:s=[],depth:i=null,since:n=null,exclude:a=[]}){const o=[];e=[...new Set(e)];let c=` ${t.join(" ")}`;for(const d of e)o.push(Ce.encode(`want ${d}${c}\n`)),c="";for(const d of s)o.push(Ce.encode(`shallow ${d}\n`));null!==i&&o.push(Ce.encode(`deepen ${i}\n`)),null!==n&&o.push(Ce.encode(`deepen-since ${Math.floor(n.valueOf()/1e3)}\n`));for(const d of a)o.push(Ce.encode(`deepen-not ${d}\n`));o.push(Ce.flush());for(const d of r)o.push(Ce.encode(`have ${d}\n`));return o.push(Ce.encode("done\n")),o}({capabilities:B,wants:N,haves:M,shallows:j.capabilities.has("shallow")?[...H]:[],depth:m,since:w,exclude:g}),z=d.from(await Ae(G)),F=await A.connect({http:r,onProgress:s,corsProxy:p,service:"git-upload-pack",url:P,auth:U,body:[z],headers:$}),q=await async function(t){const{packetlines:e,packfile:r,progress:s}=Ye.demux(t),i=[],n=[],a=[];let o=!1,c=!1;return new Promise(((t,d)=>{Ie(e,(e=>{const l=e.toString("utf8").trim();if(l.startsWith("shallow")){const t=l.slice(-41).trim();40!==t.length&&d(new D(t)),i.push(t)}else if(l.startsWith("unshallow")){const t=l.slice(-41).trim();40!==t.length&&d(new D(t)),n.push(t)}else if(l.startsWith("ACK")){const[,t,e]=l.split(" ");a.push({oid:t,status:e}),e||(c=!0)}else l.startsWith("NAK")&&(o=!0,c=!0);c&&t({shallows:i,unshallows:n,acks:a,nak:o,packfile:r,progress:s})}))}))}(F.body);F.headers&&(q.headers=F.headers);for(const d of q.shallows)if(!H.has(d))try{const{object:r}=await Pt({fs:t,cache:e,gitdir:c,oid:d}),s=new ie(r),i=await Promise.all(s.headers().parent.map((r=>Fe({fs:t,cache:e,gitdir:c,oid:r}))));0===i.length||i.every((t=>t))||H.add(d)}catch(Y){H.add(d)}for(const d of q.unshallows)H.delete(d);if(await ze.write({fs:t,gitdir:c,oids:H}),_){const e=new Map([[O,R]]),r=new Map;let s=10,i=O;for(;s--;){const t=j.symrefs.get(i);if(void 0===t)break;r.set(i,t),i=t}const n=C.get(i);n&&e.set(i,n);const{pruned:a}=await ct.updateRemoteRefs({fs:t,gitdir:c,remote:S,refs:e,symrefs:r,tags:b,prune:x});x&&(q.pruned=a)}else{const{pruned:e}=await ct.updateRemoteRefs({fs:t,gitdir:c,remote:S,refs:C,symrefs:j.symrefs,tags:b,prune:x,pruneTags:E});x&&(q.pruned=e)}if(q.HEAD=j.symrefs.get("HEAD"),void 0===q.HEAD){const{oid:t}=ct.resolveAgainstMap({ref:"HEAD",map:C});for(const[e,r]of C.entries())if("HEAD"!==e&&r===t){q.HEAD=e;break}}const L=O.startsWith("refs/tags")?"tag":"branch";if(q.FETCH_HEAD={oid:R,description:`${L} '${ke(O)}' of ${P}`},s||i){Ie(Ze(q.progress),(async t=>{if(i&&await i(t),s){const e=t.match(/([^:]*).*\((\d+?)\/(\d+?)\)/);e&&await s({phase:e[1].trim(),loaded:parseInt(e[2],10),total:parseInt(e[3],10)})}}))}const V=d.from(await Ae(q.packfile)),K=V.slice(-20).toString("hex"),Z={defaultBranch:q.HEAD,fetchHead:q.FETCH_HEAD.oid,fetchHeadDescription:q.FETCH_HEAD.description};if(q.headers&&(Z.headers=q.headers),x&&(Z.pruned=q.pruned),""!==K&&"5041434b0000000200000000"!==V.slice(0,12).toString("hex")){Z.packfile=`objects/pack/pack-${K}.pack`;const r=W(c,Z.packfile);await t.write(r,V);const i=r=>Pt({fs:t,cache:e,gitdir:c,oid:r}),n=await vt.fromPack({pack:V,getExternalRefDelta:i,onProgress:s});await t.write(r.replace(/\.pack$/,".idx"),await n.toBuffer())}return Z}async function Xe({fs:t,bare:e=!1,dir:r,gitdir:s=(e?r:W(r,".git")),defaultBranch:i="master"}){if(await t.exists(s+"/config"))return;let n=["hooks","info","objects/info","objects/pack","refs/heads","refs/tags"];n=n.map((t=>s+"/"+t));for(const a of n)await t.mkdir(a);await t.write(s+"/config",`[core]\n\trepositoryformatversion = 0\n\tfilemode = false\n\tbare = ${e}\n`+(e?"":"\tlogallrefupdates = true\n")+"\tsymlinks = false\n\tignorecase = true\n"),await t.write(s+"/HEAD",`ref: refs/heads/${i}\n`)}async function Qe({fs:t,http:e,onProgress:r,onMessage:s,onAuth:i,onAuthSuccess:n,onAuthFailure:a,dir:o,gitdir:c=W(o,".git"),url:d,corsProxy:l,ref:f,remote:u="origin",depth:h,since:p,exclude:m=[],relative:w=!1,singleBranch:g=!1,noCheckout:y=!1,noTags:b=!1,headers:_={},cache:$={}}){try{return be("fs",t),be("http",e),be("gitdir",c),y||be("dir",o),be("url",d),await async function({fs:t,cache:e,http:r,onProgress:s,onMessage:i,onAuth:n,onAuthSuccess:a,onAuthFailure:o,dir:c,gitdir:d,url:l,corsProxy:f,ref:u,remote:h,depth:p,since:m,exclude:w,relative:g,singleBranch:y,noCheckout:b,noTags:_,headers:$}){try{if(await Xe({fs:t,gitdir:d}),await _e({fs:t,gitdir:d,remote:h,url:l,force:!1}),f){const e=await nt.get({fs:t,gitdir:d});await e.set("http.corsProxy",f),await nt.save({fs:t,gitdir:d,config:e})}const{defaultBranch:x,fetchHead:E}=await Je({fs:t,cache:e,http:r,onProgress:s,onMessage:i,onAuth:n,onAuthSuccess:a,onAuthFailure:o,gitdir:d,ref:u,remote:h,corsProxy:f,depth:p,since:m,exclude:w,relative:g,singleBranch:y,headers:$,tags:!_});if(null===E)return;u=(u=u||x).replace("refs/heads/",""),await xe({fs:t,cache:e,onProgress:s,dir:c,gitdir:d,ref:u,remote:h,noCheckout:b})}catch(x){throw await t.rmdir(d,{recursive:!0,maxRetries:10}).catch((()=>{})),x}}({fs:new ye(t),cache:$,http:e,onProgress:r,onMessage:s,onAuth:i,onAuthSuccess:n,onAuthFailure:a,dir:o,gitdir:c,url:d,corsProxy:l,ref:f,remote:u,depth:h,since:p,exclude:m,relative:w,singleBranch:g,noCheckout:y,noTags:b,headers:_})}catch(x){throw x.caller="git.clone",x}}function tr(){try{return qe}catch(t){throw t.caller="git.version",t}}}}]);