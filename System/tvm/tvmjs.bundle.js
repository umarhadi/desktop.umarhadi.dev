!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("perf_hooks"),require("ws")):"function"==typeof define&&define.amd?define(["exports","perf_hooks","ws"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).tvmjs={},e.perf_hooks,e.ws)}(this,(function(e,t,r){"use strict";function s(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var i=s(t),n=s(r),a="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function o(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function c(e,t){return e(t={exports:{}},t.exports),t.exports}var h=c((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.wasmPath=t.assert=t.Uint8ArrayToString=t.StringToUint8Array=void 0,t.StringToUint8Array=function(e){const t=new Uint8Array(e.length+1);for(let r=0;r<e.length;++r)t[r]=e.charCodeAt(r);return t[e.length]=0,t},t.Uint8ArrayToString=function(e){const t=[];for(const r of e)t.push(String.fromCharCode(r));return t.join("")},t.assert=function(e,t){if(!e)throw new Error("AssertError:"+(t||""))},t.wasmPath=function(){return __dirname+"/wasm"}}));o(h),h.wasmPath,h.assert,h.Uint8ArrayToString,h.StringToUint8Array;var l=c((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.CachedCallStack=t.Memory=void 0;t.Memory=class{constructor(e){this.wasm32=!0,this.memory=e,this.buffer=this.memory.buffer,this.viewU8=new Uint8Array(this.buffer),this.viewU16=new Uint16Array(this.buffer),this.viewI32=new Int32Array(this.buffer),this.viewU32=new Uint32Array(this.buffer),this.viewF32=new Float32Array(this.buffer),this.viewF64=new Float64Array(this.buffer)}loadU8(e){return this.buffer!=this.memory.buffer&&this.updateViews(),this.viewU8[e>>0]}loadU16(e){return this.buffer!=this.memory.buffer&&this.updateViews(),this.viewU16[e>>1]}loadU32(e){return this.buffer!=this.memory.buffer&&this.updateViews(),this.viewU32[e>>2]}loadI32(e){return this.buffer!=this.memory.buffer&&this.updateViews(),this.viewI32[e>>2]}loadI64(e){this.buffer!=this.memory.buffer&&this.updateViews();const t=e>>2;return this.viewI32[t]}loadF32(e){return this.buffer!=this.memory.buffer&&this.updateViews(),this.viewF32[e>>2]}loadF64(e){return this.buffer!=this.memory.buffer&&this.updateViews(),this.viewF64[e>>3]}loadPointer(e){return this.buffer!=this.memory.buffer&&this.updateViews(),this.wasm32?this.loadU32(e):this.loadI64(e)}loadUSize(e){return this.buffer!=this.memory.buffer&&this.updateViews(),this.wasm32?this.loadU32(e):this.loadI64(e)}sizeofPtr(){return this.wasm32?4:8}loadRawBytes(e,t){this.buffer!=this.memory.buffer&&this.updateViews();const r=new Uint8Array(t);return r.set(this.viewU8.slice(e,e+t)),r}loadTVMBytes(e){const t=this.loadPointer(e),r=this.loadUSize(e+this.sizeofPtr());return this.loadRawBytes(t,r)}loadCString(e){this.buffer!=this.memory.buffer&&this.updateViews();const t=[];let r=1;for(;0!=r;)r=this.viewU8[e],0!=r&&t.push(String.fromCharCode(r)),++e;return t.join("")}storeRawBytes(e,t){this.buffer!=this.memory.buffer&&this.updateViews(),this.viewU8.set(t,e)}updateViews(){this.buffer=this.memory.buffer,this.viewU8=new Uint8Array(this.buffer),this.viewU16=new Uint16Array(this.buffer),this.viewI32=new Int32Array(this.buffer),this.viewU32=new Uint32Array(this.buffer),this.viewF32=new Float32Array(this.buffer),this.viewF64=new Float64Array(this.buffer)}};t.CachedCallStack=class{constructor(e,t,r){this.tempArgs=[],this.stackTop=0,this.basePtr=0,this.addressToSetTargetValue=[];this.memory=e,this.cAllocSpace=t,this.cFreeSpace=r,this.buffer=new ArrayBuffer(128),this.basePtr=this.cAllocSpace(128),this.viewU8=new Uint8Array(this.buffer),this.viewI32=new Int32Array(this.buffer),this.viewU32=new Uint32Array(this.buffer),this.viewF64=new Float64Array(this.buffer),this.updateViews()}dispose(){0!=this.basePtr&&(this.cFreeSpace(this.basePtr),this.basePtr=0)}reset(){for(this.stackTop=0,h.assert(0==this.addressToSetTargetValue.length);0!=this.tempArgs.length;)this.tempArgs.pop().dispose()}commitToWasmMemory(e=this.stackTop){for(;0!=this.addressToSetTargetValue.length;){const[e,t]=this.addressToSetTargetValue.pop();this.storePtr(e,this.ptrFromOffset(t))}this.memory.storeRawBytes(this.basePtr,this.viewU8.slice(0,e))}allocRawBytes(e){if(e=e+7>>3<<3,this.stackTop+e>this.buffer.byteLength){const t=Math.max(2*this.buffer.byteLength,this.stackTop+e),r=this.viewU8;this.buffer=new ArrayBuffer(t),this.updateViews(),this.viewU8.set(r),0!=this.basePtr&&this.cFreeSpace(this.basePtr),this.basePtr=this.cAllocSpace(t)}const t=this.stackTop;return this.stackTop+=e,t}allocPtrArray(e){return this.allocRawBytes(this.memory.sizeofPtr()*e)}ptrFromOffset(e){return this.basePtr+e}storePtr(e,t){this.memory.wasm32?this.storeU32(e,t):this.storeI64(e,t)}storeUSize(e,t){this.memory.wasm32?this.storeU32(e,t):this.storeI64(e,t)}storeI32(e,t){this.viewI32[e>>2]=t}storeU32(e,t){this.viewU32[e>>2]=t}storeI64(e,t){const r=4294967295&t,s=e>>2;this.viewI32[s]=r,this.viewI32[s+1]=0}storeF64(e,t){this.viewF64[e>>3]=t}storeRawBytes(e,t){this.viewU8.set(t,e)}allocThenSetArgString(e,t){const r=this.allocRawBytes(t.length+1);this.storeRawBytes(r,h.StringToUint8Array(t)),this.addressToSetTargetValue.push([e,r])}allocThenSetArgBytes(e,t){const r=this.allocRawBytes(2*this.memory.sizeofPtr()),s=this.allocRawBytes(t.length);this.storeRawBytes(s,t),this.storeUSize(r+this.memory.sizeofPtr(),t.length),this.addressToSetTargetValue.push([e,r]),this.addressToSetTargetValue.push([r,s])}updateViews(){this.viewU8=new Uint8Array(this.buffer),this.viewI32=new Int32Array(this.buffer),this.viewU32=new Uint32Array(this.buffer),this.viewF64=new Float64Array(this.buffer)}}}));o(l),l.CachedCallStack,l.Memory;var d=c((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.Environment=void 0;t.Environment=class{constructor(e={},t=console.log){this.packedCFuncTable=[void 0],this.packedCFuncTableFreeId=[],this.logger=t,this.libProvider=function(e){if(e.wasmLibraryProvider&&e.wasmLibraryProvider.start&&void 0!==e.wasmLibraryProvider.imports){const t=e;return{imports:t.wasmLibraryProvider.imports,start:e=>{t.wasmLibraryProvider.start(e)}}}return e.imports&&void 0!==e.start?e:e.wasiImport&&void 0!==e.start?{imports:{wasi_snapshot_preview1:e.wasiImport},start:t=>{e.start(t)}}:void 0}(e),void 0!==this.libProvider?this.imports=this.libProvider.imports:this.imports=e,this.imports.env=this.environment(this.imports.env)}start(e){void 0!==this.libProvider&&this.libProvider.start(e)}environment(e){const t={TVMWasmPackedCFunc:(e,t,r,s,i)=>{const n=this.packedCFuncTable[i];return h.assert(void 0!==n),n(e,t,r,s,i)},TVMWasmPackedCFuncFinalizer:e=>{this.packedCFuncTable[e]=void 0,this.packedCFuncTableFreeId.push(e)},__console_log:e=>{this.logger(e)}};return Object.assign({__cxa_thread_atexit:()=>{},emscripten_notify_memory_growth:e=>{}},e,t)}}}));o(d),d.Environment;var u=c((function(e,t){var r=a&&a.__awaiter||function(e,t,r,s){return new(r||(r=Promise))((function(i,n){function a(e){try{c(s.next(e))}catch(e){n(e)}}function o(e){try{c(s.throw(e))}catch(e){n(e)}}function c(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,o)}c((s=s.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.WebGPUContext=t.detectGPUDevice=void 0,t.detectGPUDevice=function(){return r(this,void 0,void 0,(function*(){if("undefined"!=typeof navigator&&void 0!==navigator.gpu){const e=yield navigator.gpu.requestAdapter({powerPreference:"high-performance"});if(null==e)throw Error("Cannot find adapter that matches the request");const t=e=>Math.ceil(e/(1<<20))+"MB",r=1<<30;if(r>e.limits.maxBufferSize)throw Error(`Cannot initialize runtime because of requested maxBufferSize exceeds limit. requested=${t(r)}, limit=${t(e.limits.maxBufferSize)}. This error may be caused by an older version of the browser (e.g. Chrome 112). You can try to upgrade your browser to Chrome 113 or later.`);const s=1<<30;if(s>e.limits.maxStorageBufferBindingSize)throw Error(`Cannot initialize runtime because of requested maxStorageBufferBindingSize exceeds limit. requested=${t(s)}, limit=${t(e.limits.maxStorageBufferBindingSize)}. `);const i=32768;if(i>e.limits.maxComputeWorkgroupStorageSize)throw Error(`Cannot initialize runtime because of requested maxComputeWorkgroupStorageSize exceeds limit. requested=${i}, limit=${e.limits.maxComputeWorkgroupStorageSize}. `);const n=yield e.requestAdapterInfo(),a=yield e.requestDevice({requiredLimits:{maxBufferSize:r,maxStorageBufferBindingSize:s,maxComputeWorkgroupStorageSize:i}});return{adapter:e,adapterInfo:n,device:a}}}))};const s="\n@group(0) @binding(0) var my_sampler : sampler;\n@group(0) @binding(1) var my_texture : texture_2d<f32>;\n\nstruct VertexOutput {\n  @builtin(position) position : vec4<f32>,\n  @location(0) uv : vec2<f32>,\n}\n\n@vertex\nfn vertex_main(@builtin(vertex_index) vidx : u32) -> VertexOutput {\n  const pos = array(\n    vec2( 1.0,  1.0),\n    vec2( 1.0, -1.0),\n    vec2(-1.0, -1.0),\n    vec2( 1.0,  1.0),\n    vec2(-1.0, -1.0),\n    vec2(-1.0,  1.0),\n  );\n\n  const uv = array(\n    vec2(1.0, 0.0),\n    vec2(1.0, 1.0),\n    vec2(0.0, 1.0),\n    vec2(1.0, 0.0),\n    vec2(0.0, 1.0),\n    vec2(0.0, 0.0),\n  );\n\n  var output : VertexOutput;\n  output.position = vec4(pos[vidx], 0.0, 1.0);\n  output.uv = uv[vidx];\n  return output;\n}\n\n@fragment\nfn fragment_main(@location(0) uv : vec2<f32>) -> @location(0) vec4<f32> {\n  return textureSample(my_texture, my_sampler, uv);\n}\n\n@fragment\nfn fragment_clear(@location(0) uv : vec2<f32>) -> @location(0) vec4<f32> {\n  return vec4(1.0, 1.0, 1.0, 1.0);\n}\n";class i{constructor(e,t){this.device=e;const r=t.getContext("webgpu",{alpha:!1,antialias:!1,powerPreference:"high-performance"});if(null==r)throw Error("Cannot bind WebGPU context");this.canvasContext=r,this.canvasTextureFormat=navigator.gpu.getPreferredCanvasFormat(),this.canvasContext.configure({device:this.device,format:this.canvasTextureFormat,alphaMode:"opaque"}),this.renderPipeline=e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:s}),entryPoint:"vertex_main"},fragment:{module:e.createShaderModule({code:s}),entryPoint:"fragment_main",targets:[{format:this.canvasTextureFormat}]},primitive:{topology:"triangle-list"}}),this.clearPipeline=e.createRenderPipeline({layout:"auto",vertex:{module:e.createShaderModule({code:s}),entryPoint:"vertex_main"},fragment:{module:e.createShaderModule({code:s}),entryPoint:"fragment_clear",targets:[{format:this.canvasTextureFormat}]},primitive:{topology:"triangle-list"}}),this.renderSampler=e.createSampler({magFilter:"linear",minFilter:"linear"}),this.stagingTexture=e.createTexture({size:[t.height,t.width,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT})}clear(){const e=this.device.createCommandEncoder(),t=e.beginRenderPass({colorAttachments:[{view:this.canvasContext.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});t.setPipeline(this.clearPipeline);const r=this.device.createBindGroup({layout:this.renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this.renderSampler},{binding:1,resource:this.stagingTexture.createView()}]});t.setBindGroup(0,r),t.draw(6,1,0,0),t.end(),this.device.queue.submit([e.finish()])}draw(e,t,r){t==this.stagingTexture.height&&r==this.stagingTexture.width||(this.stagingTexture.destroy(),this.stagingTexture=this.device.createTexture({size:[t,r,1],format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT}));const s=this.device.createCommandEncoder();s.copyBufferToTexture({buffer:e,offset:0,bytesPerRow:4*this.stagingTexture.width},{texture:this.stagingTexture},{width:this.stagingTexture.width,height:this.stagingTexture.height});const i=s.beginRenderPass({colorAttachments:[{view:this.canvasContext.getCurrentTexture().createView(),clearValue:{r:0,g:0,b:0,a:1},loadOp:"clear",storeOp:"store"}]});i.setPipeline(this.renderPipeline);const n=this.device.createBindGroup({layout:this.renderPipeline.getBindGroupLayout(0),entries:[{binding:0,resource:this.renderSampler},{binding:1,resource:this.stagingTexture.createView()}]});i.setBindGroup(0,n),i.draw(6,1,0,0),i.end(),this.device.queue.submit([s.finish()])}dispose(){this.stagingTexture.destroy()}}t.WebGPUContext=class{constructor(e,t){this.bufferTable=[void 0],this.bufferTableFreeId=[],this.podArgStagingBuffers=[],this.canvasRenderManager=void 0,this.maxNumPodArgsStagingBuffers=2,this.peakAllocatedBytes=0,this.currAllocatedBytes=0,this.allAllocatedBytes=0,this.shaderSubmitCounter=0,this.debugShaderSubmitLimit=-1,this.debugLogFinish=!1,this.memory=e,this.device=t}dispose(){var e,t,r;for(null===(e=this.canvasRenderManager)||void 0===e||e.dispose(),this.bufferTableFreeId=[];0!=this.bufferTable.length;)null===(t=this.bufferTable.pop())||void 0===t||t.destroy();for(;0!=this.podArgStagingBuffers.length;)null===(r=this.podArgStagingBuffers.pop())||void 0===r||r.destroy();this.device.destroy()}sync(){return r(this,void 0,void 0,(function*(){yield this.device.queue.onSubmittedWorkDone()}))}runtimeStatsText(){let e="peak-memory="+Math.ceil(this.peakAllocatedBytes/(1<<20))+" MB";return e+=", all-memory="+Math.ceil(this.allAllocatedBytes/(1<<20))+" MB",e+=", shader-submissions="+this.shaderSubmitCounter,e}drawImageFromBuffer(e,t,r){if(null==this.canvasRenderManager)throw Error("Do not have a canvas context, call bindCanvas first");this.canvasRenderManager.draw(this.gpuBufferFromPtr(e),t,r)}copyRawBytesToBuffer(e,t,r,s){this.device.queue.writeBuffer(this.gpuBufferFromPtr(t),r,e,0,s)}clearCanvas(){var e;null===(e=this.canvasRenderManager)||void 0===e||e.clear()}bindCanvas(e){this.canvasRenderManager=new i(this.device,e)}createShader(e,t){return this.createShadeInternal(e,t,!1)}createShaderAsync(e,t){return r(this,void 0,void 0,(function*(){return yield this.createShadeInternal(e,t,!0)}))}getPodArgsBuffer(e){let t;this.podArgStagingBuffers.length>=this.maxNumPodArgsStagingBuffers&&(t=this.podArgStagingBuffers.shift());let r=16;for(void 0!==t&&(r=t.size,t.size<e&&(t.destroy(),t=void 0));r<e;)r*=2;return null==t&&(t=this.device.createBuffer({size:r,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),h.assert(e<=t.size),t}createShadeInternal(e,t,r){const s=[];let i=[];for(let t=0;t<e.launch_param_tags.length;++t){const r=e.launch_param_tags[t];if(r.startsWith("blockIdx.")){const e=r.charCodeAt(r.length-1)-"x".charCodeAt(0);h.assert(e>=0&&e<3),s.push(e)}else if(r.startsWith("threadIdx.")){const e=r.charCodeAt(r.length-1)-"x".charCodeAt(0);h.assert(e>=0&&e<3),s.push(e+3)}else{if(!r.startsWith("paramWriteAccess:"))throw new Error("Cannot handle thread_axis "+r);i=JSON.parse(r.substring(17))}}const n=[],a=[],o=[];for(let t=0;t<e.arg_types.length;++t){const r=e.arg_types[t];if("handle"==r)n.push({binding:a.length,visibility:GPUShaderStage.COMPUTE,buffer:{type:i[a.length]?"storage":"read-only-storage"}}),a.push(t);else{if(!(r.startsWith("int")||r.startsWith("uint")||r.startsWith("float")))throw new Error("Cannot handle argument type "+r+" in WebGPU shader");o.push(t)}}h.assert(i.length==a.length),n.push({binding:a.length,visibility:GPUShaderStage.COMPUTE,buffer:{type:"uniform"}});const c=this.device.createBindGroupLayout({entries:n}),l=this.device.createPipelineLayout({bindGroupLayouts:[c]}),d=t=>(...r)=>{if(-1!=this.debugShaderSubmitLimit&&this.shaderSubmitCounter>=this.debugShaderSubmitLimit)return void(this.shaderSubmitCounter+=1);const i=this.device.createCommandEncoder(),n=i.beginComputePass();n.setPipeline(t);const l=[],d=a.length+o.length;h.assert(r.length==d+s.length);const u=[1,1,1,1,1,1];for(let e=0;e<s.length;++e)u[s[e]]=r[d+e];if(1!=u[2])throw Error("WebGPU: blockIdx.z is reserved for internal use");const f=u[0];if(u[0]>=65536){let e=u[0],t=u[2];for(;e>=65536;)e%2==0?e/=2:e=(e+1)/2,t*=2;u[0]=e,u[2]=t,h.assert(e*t>=f)}for(let e=0;e<a.length;++e)l.push({binding:e,resource:{buffer:this.gpuBufferFromPtr(r[a[e]])}});const p=this.getPodArgsBuffer(4*(o.length+1)),y=new Int32Array(o.length+1),m=new Uint32Array(y.buffer),g=new Float32Array(y.buffer);for(let t=0;t<o.length;++t){const s=r[o[t]],i=e.arg_types[o[t]];if(i.startsWith("int"))y[t]=s;else if(i.startsWith("uint"))m[t]=s;else{if(!i.startsWith("float"))throw Error("Unknown pod dtype "+i);g[t]=s}}m[o.length]=f,this.device.queue.writeBuffer(p,0,y.buffer),l.push({binding:a.length,resource:{buffer:p,size:y.buffer.byteLength}}),n.setBindGroup(0,this.device.createBindGroup({layout:c,entries:l})),n.dispatchWorkgroups(u[0],u[1],u[2]),n.end();const b=i.finish();if(this.device.queue.submit([b]),this.debugLogFinish){const t=this.shaderSubmitCounter;this.device.queue.onSubmittedWorkDone().then((()=>{console.log("["+t+"][Debug] finish shader"+e.name)}))}this.shaderSubmitCounter+=1},u=this.device.createShaderModule({code:t,hints:{main:{layout:l}}});if(r)return this.device.createComputePipelineAsync({layout:l,compute:{module:u,entryPoint:e.name}}).then((e=>d(e)));{const t=this.device.createComputePipeline({layout:l,compute:{module:u,entryPoint:e.name}});return d(t)}}getDeviceAPI(e){if("deviceAllocDataSpace"==e)return e=>this.deviceAllocDataSpace(e);if("deviceFreeDataSpace"==e)return e=>this.deviceFreeDataSpace(e);if("deviceCopyToGPU"==e)return(e,t,r,s)=>{this.deviceCopyToGPU(e,t,r,s)};if("deviceCopyFromGPU"==e)return(e,t,r,s)=>{this.deviceCopyFromGPU(e,t,r,s)};if("deviceCopyWithinGPU"==e)return(e,t,r,s,i)=>{this.deviceCopyWithinGPU(e,t,r,s,i)};throw new Error("Unknown DeviceAPI function "+e)}deviceAllocDataSpace(e){0==e&&(e=1);const t=this.device.createBuffer({size:e,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST});this.currAllocatedBytes+=e,this.allAllocatedBytes+=e,this.currAllocatedBytes>this.peakAllocatedBytes&&(this.peakAllocatedBytes=this.currAllocatedBytes);return this.attachToBufferTable(t)}deviceFreeDataSpace(e){const t=e,r=this.bufferTable[t];this.bufferTable[t]=void 0,h.assert(void 0!==r),this.bufferTableFreeId.push(t),this.currAllocatedBytes-=r.size,r.destroy()}deviceCopyToGPU(e,t,r,s){const i=this.memory.loadRawBytes(e,s);this.device.queue.writeBuffer(this.gpuBufferFromPtr(t),r,i,0,s)}deviceCopyFromGPU(e,t,r,s){const i=this.device.createBuffer({size:s,usage:GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST}),n=this.device.createCommandEncoder();n.copyBufferToBuffer(this.gpuBufferFromPtr(e),t,i,0,s);const a=n.finish();this.device.queue.submit([a]),i.mapAsync(GPUMapMode.READ).then((()=>{const e=i.getMappedRange();this.memory.storeRawBytes(r,new Uint8Array(e)),i.destroy()}))}deviceCopyWithinGPU(e,t,r,s,i){const n=this.device.createCommandEncoder();n.copyBufferToBuffer(this.gpuBufferFromPtr(e),t,this.gpuBufferFromPtr(r),s,i);const a=n.finish();this.device.queue.submit([a])}gpuBufferFromPtr(e){const t=this.bufferTable[e];return h.assert(void 0!==t),t}attachToBufferTable(e){if(0!=this.bufferTableFreeId.length){const t=this.bufferTableFreeId.pop();return this.bufferTable[t]=e,t}{const t=this.bufferTable.length;return this.bufferTable.push(e),t}}}}));o(u),u.WebGPUContext,u.detectGPUDevice;var f=c((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.createWebSocket=t.getPerformance=void 0,t.getPerformance=function(){if("undefined"==typeof performance){return i.default.performance}return performance},t.createWebSocket=function(e){if("undefined"==typeof WebSocket){return new(0,n.default)(e)}return new WebSocket(e)}}));o(f),f.createWebSocket,f.getPerformance;var p=c((function(e,t){var r=a&&a.__awaiter||function(e,t,r,s){return new(r||(r=Promise))((function(i,n){function a(e){try{c(s.next(e))}catch(e){n(e)}}function o(e){try{c(s.throw(e))}catch(e){n(e)}}function c(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,o)}c((s=s.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.instantiate=t.Instance=t.VirtualMachine=t.TVMArray=t.TVMObject=t.Module=t.NDArray=t.DLDataType=t.DLDevice=t.Scalar=void 0;class s{constructor(e,t){this.recycledCallStacks=[],this.wasmInstance=e,this.memory=new l.Memory(this.detectWasmMemory(this.wasmInstance,t)),h.assert(void 0!==this.wasmInstance.exports,"Expect the library module contains exports"),this.exports=this.wasmInstance.exports,this.wasm32=this.memory.wasm32,this.validateInstance()}dispose(){for(var e;0!=this.recycledCallStacks.length;)this.recycledCallStacks.pop().dispose();null===(e=this.webGPUContext)||void 0===e||e.dispose()}sizeofPtr(){return this.memory.sizeofPtr()}checkCall(e){if(0!=e){const e=this.exports.TVMGetLastError();throw new Error("TVMError: "+this.memory.loadCString(e))}}getOrAllocCallStack(){return 0!=this.recycledCallStacks.length?this.recycledCallStacks.pop():new l.CachedCallStack(this.memory,this.exports.TVMWasmAllocSpace,this.exports.TVMWasmFreeSpace)}recycleCallStack(e){e.reset(),this.recycledCallStacks.push(e)}validateInstance(){this.checkExports(["TVMWasmAllocSpace","TVMWasmFreeSpace","TVMFuncFree"])}checkExports(e){const t=[];for(const r of e){this.exports[r]instanceof Function||t.push(r)}if(0!=t.length)throw new Error("Cannot find "+t+" in exports")}detectWasmMemory(e,t){if(e.exports.memory instanceof WebAssembly.Memory)return e.exports.memory;if(t.env&&t.env.memory instanceof WebAssembly.Memory)return t.env.memory;throw new Error("Cannt detect wasm memory from imports "+t+" or exports"+e.exports)}}class i{constructor(e){this.autoDisposeScope=[],this.arrayGetItem=e("runtime.ArrayGetItem"),this.arrayGetSize=e("runtime.ArraySize"),this.arrayMake=e("runtime.Array"),this.getSysLib=e("runtime.SystemLib"),this.arrayCacheGet=e("vm.builtin.ndarray_cache.get"),this.arrayCacheRemove=e("vm.builtin.ndarray_cache.remove"),this.arrayCacheUpdate=e("vm.builtin.ndarray_cache.update"),this.arrayCacheClear=e("vm.builtin.ndarray_cache.clear"),this.arrayDecodeStorage=e("tvmjs.array.decode_storage"),this.paramModuleFromCache=e("vm.builtin.param_module_from_cache"),this.makeShapeTuple=e("runtime.ShapeTuple"),this.ndarrayCreateView=e("runtime.TVMArrayCreateView"),this.sampleTopPFromLogits=e("vm.builtin.sample_top_p_from_logits")}dispose(){this.arrayCacheClear.dispose(),this.arrayGetItem.dispose(),this.arrayGetSize.dispose(),this.arrayMake.dispose(),this.arrayCacheGet.dispose(),this.arrayCacheRemove.dispose(),this.arrayCacheUpdate.dispose(),this.arrayCacheClear.dispose(),this.arrayDecodeStorage.dispose(),this.paramModuleFromCache.dispose(),this.makeShapeTuple.dispose(),this.ndarrayCreateView.dispose(),this.sampleTopPFromLogits.dispose()}beginScope(){this.autoDisposeScope.push([])}endScope(){if(0==this.autoDisposeScope.length)throw Error("tvm.endScope called when the stack is empty.");const e=this.autoDisposeScope.pop();for(let t=0;t<e.length;++t){const r=e[t];void 0!==r&&r.dispose()}}attachToCurrentScope(e){if(0==this.autoDisposeScope.length)throw Error("Must call beginScope to use functions that returns TVM objects");return this.autoDisposeScope[this.autoDisposeScope.length-1].push(e),e}moveToParentScope(e){if(this.detachFromCurrentScope(e),this.autoDisposeScope.length<2)throw Error("moveToParentScope: Parent scope do not exist");return this.autoDisposeScope[this.autoDisposeScope.length-2].push(e),e}detachFromCurrentScope(e){const t=this.autoDisposeScope[this.autoDisposeScope.length-1];let r=0;for(let s=0;s<t.length;++s)t[s]===e&&(r+=1,t[s]=void 0);if(0==r)throw Error("Cannot find obj in the current auto conversion pool");if(r>1)throw Error("Value attached to scope multiple times");return e}}class n{constructor(e,t){this.value=e,this.dtype=t}}t.Scalar=n;class o{constructor(e,t){this.handle=e,this.lib=t}dispose(){0!=this.handle&&(this.lib.checkCall(this.lib.exports.TVMFuncFree(this.handle)),this.handle=0)}getHandle(e=!0){if(e&&0==this.handle)throw Error("PackedFunc has already been disposed");return this.handle}}const c={1:"cpu",2:"cuda",4:"opencl",8:"metal",15:"webgpu"},p={cpu:1,cuda:2,cl:4,opencl:4,vulkan:7,metal:8,webgpu:15};class y{constructor(e,t,r){const s=typeof e;if("string"==s){if(this.deviceType=p[e],null==this.deviceType)throw new Error("Cannot recogonize deviceType "+e)}else{if("number"!=s)throw new Error("Cannot take type "+s+" as deviceType");this.deviceType=e}this.deviceId=t,this.lib=r}sync(){return r(this,void 0,void 0,(function*(){this.deviceType==p.webgpu&&(h.assert(void 0!==this.lib.webGPUContext),yield this.lib.webGPUContext.sync())}))}toString(){return c[this.deviceType]+"("+this.deviceId.toString()+")"}}t.DLDevice=y;const m={0:"int",1:"uint",2:"float",3:"handle"};class g{constructor(e,t,r){this.code=e,this.bits=t,this.lanes=r}toString(){const e=m[this.code]+this.bits.toString();return 1!=this.lanes?e+"x"+this.lanes.toString():e}numStorageBytes(){return this.bits*this.lanes+7>>3}}t.DLDataType=g;class b{constructor(e,t,r,s){this.handle=e,this.isView=t,this.lib=r,this.ctx=s,this.isView?this.dltensor=e:this.dltensor=this.getDLTensorFromArrayHandle(this.handle);const i=0+this.lib.sizeofPtr(),n=i,a=i+4,o=i+8,c=o+4,h=c,l=c+1,d=l+1,u=c+4,f=u+this.lib.sizeofPtr()+this.lib.sizeofPtr();this.dataPtr=r.memory.loadPointer(this.dltensor),this.ndim=r.memory.loadI32(this.dltensor+o);const p=r.memory.loadPointer(this.dltensor+u);this.shape=[];for(let e=0;e<this.ndim;++e)this.shape.push(r.memory.loadI64(p+8*e));const m=r.memory.loadU8(this.dltensor+h),b=r.memory.loadU8(this.dltensor+l),v=r.memory.loadU16(this.dltensor+d);this.dlDataType=new g(m,b,v),this.dtype=this.dlDataType.toString();const w=r.memory.loadI32(this.dltensor+n),P=r.memory.loadI32(this.dltensor+a);this.device=new y(w,P,r),this.byteOffset=r.memory.loadI64(this.dltensor+f)}view(e){const t=e.map((e=>new n(e,"int")));return this.ctx.ndarrayCreateView(this,this.ctx.makeShapeTuple(...t))}getHandle(e=!0){if(e&&0==this.handle)throw Error("NDArray has already been disposed");return this.handle}getDataPtr(){if(0==this.handle)throw Error("NDArray has already been disposed");return this.dataPtr}dispose(){0==this.handle||this.isView||(this.lib.checkCall(this.lib.exports.TVMArrayFree(this.handle)),this.handle=0)}copyFrom(e){if(e instanceof b)return this.lib.checkCall(this.lib.exports.TVMArrayCopyFromTo(e.getHandle(),this.getHandle(),0)),this;{const t=this.shape.reduce(((e,t)=>e*t),1);if(e.length!=t)throw new Error("data size and shape mismatch data.length"+e.length+" vs "+t);let r;if("float32"==this.dtype)r=Float32Array.from(e).buffer;else if("float64"==this.dtype)r=Float64Array.from(e).buffer;else if("int32"==this.dtype)r=Int32Array.from(e).buffer;else if("int8"==this.dtype)r=Int8Array.from(e).buffer;else{if("uint8"!=this.dtype)throw new Error("Unsupported data type "+this.dtype);r=Uint8Array.from(e).buffer}return this.copyFromRawBytes(new Uint8Array(r))}}copyFromRawBytes(e){var t;if(this.device.deviceType==p.webgpu)return null===(t=this.lib.webGPUContext)||void 0===t||t.copyRawBytesToBuffer(e,this.getDataPtr(),0,e.length),this;const r=this.shape.reduce(((e,t)=>e*t),1),s=this.dlDataType.numStorageBytes()*r;if(s!=e.length)throw new Error("Expect the data's length equals nbytes="+s);const i=this.lib.getOrAllocCallStack(),n=i.allocRawBytes(s),a=i.ptrFromOffset(n);return this.lib.memory.storeRawBytes(a,e),this.lib.checkCall(this.lib.exports.TVMArrayCopyFromBytes(this.getHandle(),a,s)),this.lib.recycleCallStack(i),this}toRawBytes(){if(this.device.deviceType!=p.cpu)throw new Error("Can only sync copy CPU array, use cpu_arr.copyfrom(gpu_arr) then sync instead.");const e=this.shape.reduce(((e,t)=>e*t),1),t=this.dlDataType.numStorageBytes()*e,r=this.lib.getOrAllocCallStack(),s=r.allocRawBytes(t),i=r.ptrFromOffset(s);this.lib.checkCall(this.lib.exports.TVMArrayCopyToBytes(this.getHandle(),i,t));const n=this.lib.memory.loadRawBytes(i,t);return this.lib.recycleCallStack(r),n}toArray(){const e=this.dtype;if("float32"==e)return new Float32Array(this.toRawBytes().buffer);if("float64"==e)return new Float64Array(this.toRawBytes().buffer);if("int32"==e)return new Int32Array(this.toRawBytes().buffer);if("int8"==e)return new Int8Array(this.toRawBytes().buffer);if("uint8"==e)return new Uint8Array(this.toRawBytes().buffer);throw new Error("Unsupported data type "+this.dtype)}getDLTensorFromArrayHandle(e){return e}}t.NDArray=b;class v{constructor(e,t,r){this.handle=e,this.lib=t,this.makePackedFunc=r}dispose(){0!=this.handle&&(this.lib.checkCall(this.lib.exports.TVMModFree(this.handle)),this.handle=0)}getHandle(e=!0){if(e&&0==this.handle)throw Error("Module has already been disposed");return this.handle}getFunction(e,t=!0){if(0==this.handle)throw Error("Module has already been disposed");const r=this.lib.getOrAllocCallStack(),s=r.allocRawBytes(e.length+1);r.storeRawBytes(s,h.StringToUint8Array(e));const i=r.allocPtrArray(1),n=r.ptrFromOffset(i);r.commitToWasmMemory(i),this.lib.checkCall(this.lib.exports.TVMModGetFunction(this.getHandle(),r.ptrFromOffset(s),t?1:0,n));const a=this.lib.memory.loadPointer(n);if(this.lib.recycleCallStack(r),0==a)throw Error("Cannot find function "+e);return this.makePackedFunc(a)}importModule(e){this.lib.checkCall(this.lib.exports.TVMModImport(this.getHandle(),e.getHandle()))}}t.Module=v;class w{constructor(e,t,r){this.handle=e,this.lib=t,this.ctx=r}dispose(){0!=this.handle&&(this.lib.checkCall(this.lib.exports.TVMObjectFree(this.handle)),this.handle=0)}getHandle(e=!0){if(e&&0==this.handle)throw Error("Module has already been disposed");return this.handle}typeIndex(){if(0==this.handle)throw Error("The current Object has already been disposed");const e=this.lib.getOrAllocCallStack(),t=e.allocPtrArray(1),r=e.ptrFromOffset(t);this.lib.checkCall(this.lib.exports.TVMObjectGetTypeIndex(this.getHandle(),r));const s=this.lib.memory.loadU32(r);return this.lib.recycleCallStack(e),s}typeKey(){const e=this.typeIndex(),t=this.lib.getOrAllocCallStack(),r=t.allocPtrArray(1),s=t.ptrFromOffset(r);this.lib.checkCall(this.lib.exports.TVMObjectTypeIndex2Key(e,s));const i=this.lib.memory.loadCString(this.lib.memory.loadPointer(s));return this.lib.recycleCallStack(t),i}}t.TVMObject=w;class P extends w{constructor(e,t,r){super(e,t,r)}size(){return this.ctx.arrayGetSize(this)}get(e){return this.ctx.arrayGetItem(this,new n(e,"int32"))}}t.TVMArray=P;class S{constructor(e,t){this.mod=e,this.mod.getFunction("vm_initialization")(new n(t.deviceType,"int"),new n(t.deviceId,"int"),new n(2,"int"),new n(p.cpu,"int"),new n(0,"int"),new n(2,"int"))}dispose(){this.mod.dispose()}getFunction(e){return this.mod.getFunction(e)}getInternalModule(){return this.mod}}t.VirtualMachine=S;class C{constructor(e,t={},r,n){this.cacheMetadata={},this.initProgressCallback=[],r instanceof WebAssembly.Instance?h.assert(n instanceof d.Environment,"env must be provided when passing in instance"):(h.assert(void 0===n),n=new d.Environment(t),r=new WebAssembly.Instance(e,n.imports)),n.start(r),this.env=n,this.lib=new s(r,n.imports),this.memory=this.lib.memory,this.exports=this.lib.exports,this.objFactory=new Map,this.ctx=new i((e=>this.getGlobalFuncInternal(e,!1))),this.registerEnvGlobalPackedFuncs(),this.registerObjectFactoryFuncs()}benchmark(e,t,s=10,i=1){return r(this,void 0,void 0,(function*(){const r=f.getPerformance(),n=[];this.withNewScope(e),yield t.sync();for(let a=0;a<i;++a){const i=r.now();for(let t=0;t<s;++t)this.withNewScope(e);yield t.sync();const a=r.now();n.push((a-i)/s)}return n}))}dispose(){this.ctx.dispose(),this.lib.dispose()}runtimeStatsText(){return void 0!==this.lib.webGPUContext?this.lib.webGPUContext.runtimeStatsText():""}beginScope(){this.ctx.beginScope()}endScope(){this.ctx.endScope()}withNewScope(e){this.beginScope();const t=e();return this.endScope(),t}attachToCurrentScope(e){return this.ctx.attachToCurrentScope(e)}moveToParentScope(e){return this.ctx.moveToParentScope(e)}detachFromCurrentScope(e){return this.ctx.detachFromCurrentScope(e)}systemLib(){return this.ctx.getSysLib()}listGlobalFuncNames(){const e=this.lib.getOrAllocCallStack(),t=e.allocPtrArray(2),r=e.ptrFromOffset(t),s=e.ptrFromOffset(t+this.lib.sizeofPtr());this.lib.checkCall(this.exports.TVMFuncListGlobalNames(r,s));const i=this.memory.loadI32(r),n=this.memory.loadPointer(s),a=[];for(let e=0;e<i;++e)a.push(this.memory.loadCString(this.memory.loadPointer(n+this.lib.sizeofPtr()*e)));return this.lib.recycleCallStack(e),a}registerFunc(e,t,r=!1){this.withNewScope((()=>{const s=this.toPackedFuncInternal(t,!0),i=r?1:0,n=this.lib.getOrAllocCallStack(),a=n.allocRawBytes(e.length+1);n.storeRawBytes(a,h.StringToUint8Array(e)),n.commitToWasmMemory(),this.lib.checkCall(this.lib.exports.TVMFuncRegisterGlobal(n.ptrFromOffset(a),s._tvmPackedCell.getHandle(),i)),this.lib.recycleCallStack(n)}))}getGlobalFunc(e){return this.getGlobalFuncInternal(e,!0)}getGlobalFuncInternal(e,t=!0){const r=this.lib.getOrAllocCallStack(),s=r.allocRawBytes(e.length+1);r.storeRawBytes(s,h.StringToUint8Array(e));const i=r.allocPtrArray(1),n=r.ptrFromOffset(i);r.commitToWasmMemory(i),this.lib.checkCall(this.exports.TVMFuncGetGlobal(r.ptrFromOffset(s),n));const a=this.memory.loadPointer(n);if(this.lib.recycleCallStack(r),0==a)throw Error("Cannot find global function "+e);const o=this.makePackedFunc(a);return t&&this.ctx.attachToCurrentScope(o),o}isPackedFunc(e){return"function"==typeof e&&e.hasOwnProperty("_tvmPackedCell")}toPackedFunc(e){return this.toPackedFuncInternal(e,!0)}toPackedFuncInternal(e,t){if(this.isPackedFunc(e))return e;const r=this.createPackedFuncFromCFunc(this.wrapJSFuncAsPackedCFunc(e));return t?this.ctx.attachToCurrentScope(r):r}createVirtualMachine(e){const t=this.ctx.detachFromCurrentScope(this.systemLib().getFunction("vm_load_executable")());return this.ctx.attachToCurrentScope(new S(t,e))}registerInitProgressCallback(e){this.initProgressCallback.push(e)}getParamsFromCache(e,t){return this.ctx.paramModuleFromCache(e,new n(t,"int32")).getFunction("get_params")()}ndarrayCacheGet(e){return this.ctx.arrayCacheGet(e)}ndarrayCacheRemove(e){return this.ctx.arrayCacheRemove(e)}ndarrayCacheUpdate(e,t,r=!1){this.ctx.arrayCacheUpdate(e,t,this.scalar(r?1:0,"int32"))}ndarrayCacheClear(){this.ctx.arrayCacheClear()}fetchNDArrayCache(e,t){return r(this,void 0,void 0,(function*(){const r=new URL("ndarray-cache.json",e).href,s=new Request(r),i=yield caches.open("tvmjs");let n,a=yield i.match(s);if(void 0===a&&(yield i.add(s),a=yield i.match(s)),void 0===a){this.env.logger("Error: Cannot cache "+r+", reloading will be slow");try{a=yield fetch(s)}catch(e){this.env.logger("Cannot fetch "+r)}}a instanceof Response&&(n=yield a.json()),yield this.fetchNDArrayCacheInternal(e,n.records,t),this.cacheMetadata=Object.assign(Object.assign({},this.cacheMetadata),n.metadata)}))}fetchNDArrayCacheInternal(e,t,s){return r(this,void 0,void 0,(function*(){const r=f.getPerformance();let i=r.now(),n=0;for(let e=0;e<t.length;++e)n+=t[e].nbytes;let a=0,o=0;const c=e=>{for(let r=0;r<this.initProgressCallback.length;++r){let s="["+e+"/"+t.length+"]: ";s+=Math.ceil(a/1048576).toString()+" MB, ",s+=Math.floor(100*a/n).toString()+"% complete, ",s+=o+" secs",this.initProgressCallback[r]({progress:a/n,timeElapsed:o,text:s})}};for(let e=0;e<this.initProgressCallback.length;++e)this.initProgressCallback[e]({progress:a/n,timeElapsed:0,text:"Start to fetch params"});const h=yield caches.open("tvmjs");for(let n=0;n<t.length;++n){c(n),a+=t[n].nbytes;const l=new URL(t[n].dataPath,e).href,d=new Request(l);let u;try{let e=yield h.match(d);void 0===e&&(yield h.add(d),e=yield h.match(d)),null==e&&(this.env.logger("Error: Cannot cache "+l+", reloading will be slow"),e=yield fetch(d)),u=yield e.arrayBuffer()}catch(e){throw this.env.logger("Error: Cannot fetch "+l+" err= "+e),e}const f=t[n].records;for(let e=0;e<f.length;++e){const t=f[e],r=this.withNewScope((()=>this.detachFromCurrentScope(this.empty(t.shape,t.dtype,this.cpu())))),i=u.slice(t.byteOffset,t.byteOffset+t.nbytes);if(this.ctx.arrayDecodeStorage(r,new Uint8Array(i),t.format),s.deviceType==p.cpu)this.ndarrayCacheUpdate(t.name,r,!1),r.dispose();else{const e=this.withNewScope((()=>this.detachFromCurrentScope(this.empty(t.shape,t.dtype,s))));e.copyFrom(r),yield s.sync(),this.ndarrayCacheUpdate(t.name,e,!1),r.dispose(),e.dispose()}}o=Math.ceil((r.now()-i)/1e3)}c(t.length)}))}toDLDataType(e){if(e instanceof g)return e;if("string"==typeof e){let t,r=e,s=32,i=1;if("float"==r.substring(0,5))r=r.substring(5,r.length),t=2;else if("int"==r.substring(0,3))r=r.substring(3,r.length),t=0;else if("uint"==r.substring(0,4))r=r.substring(4,r.length),t=1;else{if("handle"!=r.substring(0,6))throw new Error("Unknown dtype "+e);r=r.substring(5,r.length),t=3,s=64}const n=r.split("x");if(n.length>=1){const e=parseInt(n[0]);e+""==n[0]&&(s=e)}return n.length>=2&&(i=parseInt(n[1])),new g(t,s,i)}throw new Error("Unknown dtype "+e)}scalar(e,t){return new n(e,t)}device(e,t=0){return new y(e,t,this.lib)}cpu(e=0){return this.device("cpu",e)}webgpu(e=0){return this.device("webgpu",e)}empty(e,t="float32",r=this.device("cpu",0)){t=this.toDLDataType(t),e="number"==typeof e?[e]:e;const s=this.lib.getOrAllocCallStack(),i=s.allocRawBytes(8*e.length);for(let t=0;t<e.length;++t)s.storeI64(i+8*t,e[t]);const n=s.allocPtrArray(1),a=s.ptrFromOffset(n);s.commitToWasmMemory(n),this.lib.checkCall(this.exports.TVMArrayAlloc(s.ptrFromOffset(i),e.length,t.code,t.bits,t.lanes,r.deviceType,r.deviceId,a));const o=this.ctx.attachToCurrentScope(new b(this.memory.loadPointer(a),!1,this.lib,this.ctx));return this.lib.recycleCallStack(s),o}uniform(e,t,r,s){const i=this.empty(e,"float32",s),n=e.reduce(((e,t)=>e*t),1),a=r-t,o=new Float32Array(n);for(let e=0;e<o.length;++e)o[e]=t+Math.random()*a;return i.copyFrom(o)}sampleTopPFromLogits(e,t,r){return this.ctx.sampleTopPFromLogits(e,t,r,Math.random())}bindCanvas(e){var t;null===(t=this.lib.webGPUContext)||void 0===t||t.bindCanvas(e)}showImage(e){var t;if(2!=e.shape.length)throw Error("Require a height x width uint32 NDArray in RGBAget shape="+e.shape.toString()+" instead.");if(e.device.deviceType!=p.webgpu)throw new Error("Can only run showImage on WebGPU array, get "+c[e.device.deviceType]+" instead.");if("uint32"!=e.dtype)throw Error("Require a height x width uint32 NDArray in RGBA, get "+e.dtype+" instead.");null===(t=this.lib.webGPUContext)||void 0===t||t.drawImageFromBuffer(e.getDataPtr(),e.shape[0],e.shape[1])}clearCanvas(){var e;null===(e=this.lib.webGPUContext)||void 0===e||e.clearCanvas()}makeTVMArray(e){return this.ctx.arrayMake(...e)}makeShapeTuple(e){const t=e.map((e=>new n(e,"int")));return this.ctx.makeShapeTuple(...t)}typeKey2Index(e){const t=this.lib.getOrAllocCallStack(),r=t.allocRawBytes(e.length+1);t.storeRawBytes(r,h.StringToUint8Array(e));const s=t.allocPtrArray(1),i=t.ptrFromOffset(s);t.commitToWasmMemory(s),this.lib.checkCall(this.lib.exports.TVMObjectTypeKey2Index(t.ptrFromOffset(r),i));const n=this.memory.loadU32(i);return this.lib.recycleCallStack(t),n}registerObjectConstructor(e,t,r=!1){const s=this.typeKey2Index(e);if(this.objFactory.has(s)&&!r)throw new Error("Type "+e+" already registered");this.objFactory.set(s,t)}registerAsyncServerFunc(e,t,r=!1){this.registerFunc("__async."+e,((...e)=>{const r=e.slice(0,e.length-1),s=this.detachFromCurrentScope(e[e.length-1]);t(...r).then((e=>{s(this.scalar(4,"int32"),e),s.dispose()}))}),r)}asyncLoadWebGPUPiplines(e){return r(this,void 0,void 0,(function*(){if(null==this.lib.webGPUContext)throw Error("WebGPU not initialied");const t=this.lib.webGPUContext;this.beginScope();const r=e.getFunction("webgpu.get_fmap",!0)();let s=JSON.parse(r);s.length;const i=this.detachFromCurrentScope(e.getFunction("webgpu.get_shader")),n=this.detachFromCurrentScope(e.getFunction("webgpu.update_prebuild"));this.endScope();const a=f.getPerformance(),o=a.now();let c=o,l=0;const d=Object.entries(s);let u=Promise.resolve();for(const[e,r]of d){const s=i(e);h.assert(e==r.name);const f=t.createShaderAsync(r,s).then((t=>{this.beginScope(),n(e,t),this.endScope()})).then((()=>{l+=1;const e=a.now();if(e-c<1e3&&l!=d.length)return;c=e;const t=Math.ceil((a.now()-o)/1e3);for(let e=0;e<this.initProgressCallback.length;++e){const r=l/d.length;let s="Loading GPU shader modules["+l+"/"+d.length+"]: ";s+=Math.floor(100*r).toString()+"% completed, ",s+=t+" secs elapsed.",this.initProgressCallback[e]({progress:r,timeElapsed:t,text:s})}}));u=Promise.all([u,f]).then((()=>{}))}yield u,h.assert(l==d.length)}))}initWebGPU(e){const t=new u.WebGPUContext(this.memory,e);this.registerFunc("wasm.WebGPUDeviceAPI",(e=>t.getDeviceAPI(e))),this.registerFunc("wasm.WebGPUCreateShader",((e,r)=>{const s=JSON.parse(e);return t.createShader(s,r)})),this.registerAsyncServerFunc("wasm.WebGPUWaitForTasks",(()=>r(this,void 0,void 0,(function*(){yield t.sync()})))),this.lib.webGPUContext=t}registerObjectFactoryFuncs(){this.registerObjectConstructor("Array",((e,t,r)=>new P(e,t,r)))}registerEnvGlobalPackedFuncs(){const e=f.getPerformance();this.registerAsyncServerFunc("wasm.TimeExecution",((t,s,i,n,a,o,c,h)=>r(this,void 0,void 0,(function*(){this.ctx.detachFromCurrentScope(t),t(this.scalar(1,"int32")),yield s.sync();const r=[];let l=i;for(let i=0;i<n;++i){let n=0,d=0;do{if(n>0){let e=1.618;l=Math.floor(Math.max(a/(n/l)+1,l*e))}const r=e.now();t(this.scalar(l,"int32")),yield s.sync();n=e.now()-r,0==n&&d++}while(n<a&&d<o);const u=n/l/1e3;r.push(u),c>0&&i%h==0&&(yield new Promise((e=>setTimeout(e,c))))}const d=new Float64Array(r.length);return d.set(r),t.dispose(),new Uint8Array(d.buffer)})))),this.registerAsyncServerFunc("testing.asyncAddOne",(e=>r(this,void 0,void 0,(function*(){return yield new Promise((e=>setTimeout(e,100))),e+1}))))}createPackedFuncFromCFunc(e){let t=this.env.packedCFuncTable.length;0!=this.env.packedCFuncTableFreeId.length?t=this.env.packedCFuncTableFreeId.pop():this.env.packedCFuncTable.push(void 0),this.env.packedCFuncTable[t]=e;const r=this.lib.getOrAllocCallStack(),s=r.allocPtrArray(1),i=r.ptrFromOffset(s);this.lib.checkCall(this.exports.TVMWasmFuncCreateFromCFunc(t,i));const n=this.makePackedFunc(this.memory.loadPointer(i));return this.lib.recycleCallStack(r),n}setPackedArguments(e,t,r,s){for(let i=0;i<t.length;++i){let a=t[i];const o=typeof a,c=r+8*i,l=s+4*i;if(a instanceof b)a.isView?(e.storePtr(c,a.getHandle()),e.storeI32(l,7)):(e.storePtr(c,a.getHandle()),e.storeI32(l,13));else if(a instanceof n)a.dtype.startsWith("int")||a.dtype.startsWith("uint")?(e.storeI64(c,a.value),e.storeI32(l,0)):a.dtype.startsWith("float")?(e.storeF64(c,a.value),e.storeI32(l,2)):(h.assert("handle"==a.dtype,"Expect handle"),e.storePtr(c,a.value),e.storeI32(l,3));else if(a instanceof y)e.storeI32(c,a.deviceType),e.storeI32(c+4,a.deviceType),e.storeI32(l,6);else if("number"==o)e.storeF64(c,a),e.storeI32(l,2);else if("function"==o&&a.hasOwnProperty("_tvmPackedCell"))e.storePtr(c,a._tvmPackedCell.getHandle()),e.storeI32(l,10);else if(null===a||null==a)e.storePtr(c,0),e.storeI32(l,4);else if("string"==o)e.allocThenSetArgString(c,a),e.storeI32(l,11);else if(a instanceof Uint8Array)e.allocThenSetArgBytes(c,a),e.storeI32(l,12);else if(a instanceof Function)a=this.toPackedFuncInternal(a,!1),e.tempArgs.push(a),e.storePtr(c,a._tvmPackedCell.getHandle()),e.storeI32(l,10);else if(a instanceof v)e.storePtr(c,a.getHandle()),e.storeI32(l,9);else{if(!(a instanceof w))throw new Error("Unsupported argument type "+o);e.storePtr(c,a.getHandle()),e.storeI32(l,8)}}}wrapJSFuncAsPackedCFunc(e){const t=this.lib;return(r,s,i,n,a)=>{const o=[];this.ctx.beginScope();for(let e=0;e<i;++e){const i=r+8*e,n=s+4*e;let a=t.memory.loadI32(n);8!=a&&14!=a&&10!=a&&13!=a&&9!=a||t.checkCall(t.exports.TVMCbArgToReturn(i,n)),a=t.memory.loadI32(n),o.push(this.retValueToJS(i,a,!0))}const c=e(...o);if(this.ctx.endScope(),null!=c){const e=t.getOrAllocCallStack(),r=e.allocRawBytes(8),s=e.allocRawBytes(4);this.setPackedArguments(e,[c],r,s);const i=e.ptrFromOffset(r),a=e.ptrFromOffset(s);e.commitToWasmMemory(),t.checkCall(t.exports.TVMCFuncSetReturn(n,i,a,1)),t.recycleCallStack(e)}return 0}}makePackedFunc(e){const t=new o(e,this.lib),r=(...e)=>{const r=this.lib.getOrAllocCallStack(),s=r.allocRawBytes(8*e.length),i=r.allocRawBytes(4*e.length);this.setPackedArguments(r,e,s,i);const n=r.allocRawBytes(8),a=r.allocRawBytes(4),o=r.ptrFromOffset(n),c=r.ptrFromOffset(a);r.commitToWasmMemory(n),this.lib.checkCall(this.exports.TVMFuncCall(t.getHandle(),r.ptrFromOffset(s),r.ptrFromOffset(i),e.length,o,c));const h=this.retValueToJS(o,this.memory.loadI32(c),!1);return this.lib.recycleCallStack(r),h};return r.dispose=()=>{t.dispose()},r._tvmPackedCell=t,r}retValueToJS(e,t,r){switch(t){case 0:case 1:return this.memory.loadI64(e);case 2:return this.memory.loadF64(e);case 3:return this.memory.loadPointer(e);case 13:return this.ctx.attachToCurrentScope(new b(this.memory.loadPointer(e),!1,this.lib,this.ctx));case 7:return h.assert(r),new b(this.memory.loadPointer(e),!0,this.lib,this.ctx);case 10:return this.ctx.attachToCurrentScope(this.makePackedFunc(this.memory.loadPointer(e)));case 9:return this.ctx.attachToCurrentScope(new v(this.memory.loadPointer(e),this.lib,(e=>this.ctx.attachToCurrentScope(this.makePackedFunc(e)))));case 8:{const t=new w(this.memory.loadPointer(e),this.lib,this.ctx),r=this.objFactory.get(t.typeIndex());return null!=r?this.ctx.attachToCurrentScope(r(t.getHandle(),this.lib,this.ctx)):this.ctx.attachToCurrentScope(t)}case 4:return;case 6:{const t=this.memory.loadI32(e),r=this.memory.loadI32(e+4);return this.device(t,r)}case 11:return this.memory.loadCString(this.memory.loadPointer(e));case 12:return this.memory.loadTVMBytes(this.memory.loadPointer(e));default:throw new Error("Unsupported return type code="+t)}}}t.Instance=C,t.instantiate=function(e,t={},r=console.log){const s=new d.Environment(t,r);return WebAssembly.instantiate(e,s.imports).then((e=>new C(e.module,{},e.instance,s)))}}));o(p),p.instantiate,p.Instance,p.VirtualMachine,p.TVMArray,p.TVMObject,p.Module,p.NDArray,p.DLDataType,p.DLDevice,p.Scalar;var y=c((function(e,t){var r,s=a&&a.__awaiter||function(e,t,r,s){return new(r||(r=Promise))((function(i,n){function a(e){try{c(s.next(e))}catch(e){n(e)}}function o(e){try{c(s.throw(e))}catch(e){n(e)}}function c(e){var t;e.done?i(e.value):(t=e.value,t instanceof r?t:new r((function(e){e(t)}))).then(a,o)}c((s=s.apply(e,t||[])).next())}))};Object.defineProperty(t,"__esModule",{value:!0}),t.RPCServer=void 0,function(e){e[e.InitHeader=0]="InitHeader",e[e.InitHeaderKey=1]="InitHeaderKey",e[e.InitServer=2]="InitServer",e[e.WaitForCallback=3]="WaitForCallback",e[e.ReceivePacketHeader=4]="ReceivePacketHeader",e[e.ReceivePacketBody=5]="ReceivePacketBody"}(r||(r={}));const i=1045105;class n{constructor(e){this.offset=0,this.bytes=e}readU32(){const e=this.offset,t=this.bytes,r=t[e]|t[e+1]<<8|t[e+2]<<16|t[e+3]<<24;return this.offset+=4,r}readU64(){const e=this.readU32();return this.offset+=4,e}readByteArray(){const e=this.readU64();h.assert(this.offset+e<=this.bytes.byteLength);const t=new Uint8Array(e);return t.set(this.bytes.slice(this.offset,this.offset+e)),this.offset+=e,t}}class o{constructor(e,t,s,i=console.log,n="",a="cpu",o=void 0,c=void 0){this.state=r.InitHeader,this.pendingSend=Promise.resolve(),this.inst=void 0,this.globalObjects=[],this.currPacketLength=0,this.remoteKeyLength=0,this.pendingBytes=0,this.buffredBytes=0,this.messageQueue=[],this.url=e,this.key=t,this.name="WebSocketRPCServer["+this.key+"]: ",this.getImports=s,this.logger=i,this.ndarrayCacheUrl=n,this.ndarrayCacheDevice=a,this.initProgressCallback=o,this.asyncOnServerLoad=c,this.checkLittleEndian(),this.socket=f.createWebSocket(e),this.socket.binaryType="arraybuffer",this.socket.addEventListener("open",(e=>this.onOpen(e))),this.socket.addEventListener("message",(e=>this.onMessage(e))),this.socket.addEventListener("close",(e=>this.onClose(e)))}onClose(e){void 0!==this.inst&&(this.globalObjects.forEach((e=>{e.dispose()})),this.log(this.inst.runtimeStatsText()),this.inst.dispose()),this.state==r.ReceivePacketHeader?(this.log("Closing the server in clean state"),this.log("Automatic reconnecting.."),new o(this.url,this.key,this.getImports,this.logger,this.ndarrayCacheUrl,this.ndarrayCacheDevice,this.initProgressCallback,this.asyncOnServerLoad)):this.log("Closing the server, final state="+this.state)}onOpen(e){let t=h.StringToUint8Array("server:"+this.key);t=t.slice(0,t.length-1);const s=new Int32Array(1);s[0]=i,this.socket.send(s),s[0]=t.length,this.socket.send(s),this.socket.send(t),this.log("connected..."),this.requestBytes(8),this.state=r.InitHeader}onMessage(e){const t=e.data;this.buffredBytes+=t.byteLength,this.messageQueue.push(new Uint8Array(t)),this.processEvents()}processEvents(){for(;this.buffredBytes>=this.pendingBytes&&0!=this.pendingBytes;)this.onDataReady()}onDataReady(){switch(this.state){case r.InitHeader:this.handleInitHeader();break;case r.InitHeaderKey:this.handleInitHeaderKey();break;case r.ReceivePacketHeader:{this.currPacketHeader=this.readFromBuffer(8);const e=new n(this.currPacketHeader);this.currPacketLength=e.readU64(),h.assert(0==this.pendingBytes),this.requestBytes(this.currPacketLength),this.state=r.ReceivePacketBody;break}case r.ReceivePacketBody:{const e=this.readFromBuffer(this.currPacketLength);h.assert(0==this.pendingBytes),h.assert(void 0!==this.currPacketHeader),this.onPacketReady(this.currPacketHeader,e);break}case r.WaitForCallback:h.assert(0==this.pendingBytes);break;default:throw new Error("Cannot handle state "+this.state)}}onPacketReady(e,t){if(void 0===this.inst){const r=new n(t);r.readU32(),h.Uint8ArrayToString(r.readByteArray());const s=r.readU32(),i=[],a=[];for(let e=0;e<s;++e)i.push(r.readU32());for(let e=0;e<s;++e){const t=i[e];if(11==t){const e=h.Uint8ArrayToString(r.readByteArray());a.push(e)}else{if(12!=t)throw new Error("cannot support type code "+t);a.push(r.readByteArray())}}this.onInitServer(a,e,t)}else h.assert(void 0!==this.serverRecvData),this.serverRecvData(e,t),this.requestBytes(8),this.state=r.ReceivePacketHeader}onInitServer(e,t,i){h.assert("rpc.WasmSession"==e[0]),h.assert(0==this.pendingBytes);this.state=r.WaitForCallback,(()=>{s(this,void 0,void 0,(function*(){h.assert(e[1]instanceof Uint8Array);const n=yield p.instantiate(e[1].buffer,this.getImports(),this.logger);try{const e=yield u.detectGPUDevice();if(void 0!==e){const t="WebGPU: "+e.adapterInfo.description;this.log("Initialize GPU device: "+t),n.initWebGPU(e.device)}else this.log("Cannot find WebGPU device in the env")}catch(e){this.log("Cannnot initialize WebGPU, "+e.toString())}this.inst=n,this.inst.beginScope(),void 0!==this.initProgressCallback&&this.inst.registerInitProgressCallback(this.initProgressCallback),0!=this.ndarrayCacheUrl.length&&("cpu"==this.ndarrayCacheDevice?yield this.inst.fetchNDArrayCache(this.ndarrayCacheUrl,this.inst.cpu()):(h.assert("webgpu"==this.ndarrayCacheDevice),yield this.inst.fetchNDArrayCache(this.ndarrayCacheUrl,this.inst.webgpu()))),h.assert(void 0!==this.inst),void 0!==this.asyncOnServerLoad&&(yield this.asyncOnServerLoad(this.inst));const a=this.inst.getGlobalFunc("rpc.CreateEventDrivenServer")((e=>{if(h.assert(void 0!==this.inst),1==this.socket.readyState){const t=()=>s(this,void 0,void 0,(function*(){const t=4096;for(let r=0;r<e.length;r+=t){const s=Math.min(r+t,e.length);for(;this.socket.bufferedAmount>=16384;)yield new Promise((e=>setTimeout(e,20)));this.socket.send(e.slice(r,s))}}));return this.pendingSend=this.pendingSend.then(t),this.inst.scalar(e.length,"int32")}return this.inst.scalar(0,"int32")}),this.name,this.key);this.globalObjects.push(this.inst.detachFromCurrentScope(a));const o=this.inst.scalar(3,"int32");this.serverRecvData=(e,t)=>{0==a(e,o)&&this.socket.close(),0==a(t,o)&&this.socket.close()};const c=this.inst.getGlobalFunc("wasm.LocalSession")();h.assert(c instanceof p.Module),this.inst.registerFunc("rpc.WasmSession",(e=>c)),a(t,o),a(i,o),this.log("Finish initializing the Wasm Server.."),this.requestBytes(8),this.state=r.ReceivePacketHeader,this.processEvents(),this.inst.endScope()}))})()}log(e){this.logger(this.name+e)}handleInitHeader(){const e=new n(this.readFromBuffer(8)),t=e.readU32();if(1045106==t)throw new Error("key: "+this.key+" has already been used in proxy");if(1045107==t)throw new Error("RPCProxy do not have matching client key "+this.key);h.assert(t==i,this.url+" is not an RPC Proxy"),this.remoteKeyLength=e.readU32(),h.assert(0==this.pendingBytes),this.requestBytes(this.remoteKeyLength),this.state=r.InitHeaderKey}handleInitHeaderKey(){h.Uint8ArrayToString(this.readFromBuffer(this.remoteKeyLength)),h.assert(0==this.pendingBytes),this.requestBytes(8),this.state=r.ReceivePacketHeader}checkLittleEndian(){const e=new ArrayBuffer(4),t=new Uint8Array(e),r=new Uint32Array(e);t[0]=17,t[1]=34,t[2]=51,t[3]=68,h.assert(1144201745===r[0],"RPCServer little endian to work")}requestBytes(e){this.pendingBytes+=e}readFromBuffer(e){const t=new Uint8Array(e);let r=0;for(;r<e;){h.assert(0!=this.messageQueue.length);const s=e-r;if(this.messageQueue[0].byteLength<=s){const e=this.messageQueue.shift();t.set(e,r),r+=e.byteLength}else{const e=this.messageQueue[0];t.set(e.slice(0,s),r),this.messageQueue[0]=e.slice(s,e.byteLength),r+=s}}return this.buffredBytes-=e,this.pendingBytes-=e,t}}t.RPCServer=o}));o(y),y.RPCServer;var m=c((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"Scalar",{enumerable:!0,get:function(){return p.Scalar}}),Object.defineProperty(t,"DLDevice",{enumerable:!0,get:function(){return p.DLDevice}}),Object.defineProperty(t,"DLDataType",{enumerable:!0,get:function(){return p.DLDataType}}),Object.defineProperty(t,"Module",{enumerable:!0,get:function(){return p.Module}}),Object.defineProperty(t,"NDArray",{enumerable:!0,get:function(){return p.NDArray}}),Object.defineProperty(t,"TVMArray",{enumerable:!0,get:function(){return p.TVMArray}}),Object.defineProperty(t,"Instance",{enumerable:!0,get:function(){return p.Instance}}),Object.defineProperty(t,"instantiate",{enumerable:!0,get:function(){return p.instantiate}}),Object.defineProperty(t,"RPCServer",{enumerable:!0,get:function(){return y.RPCServer}}),Object.defineProperty(t,"wasmPath",{enumerable:!0,get:function(){return h.wasmPath}}),Object.defineProperty(t,"detectGPUDevice",{enumerable:!0,get:function(){return u.detectGPUDevice}});var r=h;Object.defineProperty(t,"assert",{enumerable:!0,get:function(){return r.assert}})})),g=o(m),b=m.Scalar,v=m.DLDevice,w=m.DLDataType,P=m.Module,S=m.NDArray,C=m.TVMArray,T=m.Instance,k=m.instantiate,F=m.RPCServer,x=m.wasmPath,A=m.detectGPUDevice,U=m.assert;e.DLDataType=w,e.DLDevice=v,e.Instance=T,e.Module=P,e.NDArray=S,e.RPCServer=F,e.Scalar=b,e.TVMArray=C,e.assert=U,e.default=g,e.detectGPUDevice=A,e.instantiate=k,e.wasmPath=x,Object.defineProperty(e,"__esModule",{value:!0})}));